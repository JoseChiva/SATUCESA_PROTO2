#<AdxTL>@(#)6.0.0.0 $Revision$
#########################################################################
# SUBPTH :               Gestion des réceptions                         #
# --------------------------------------------------------------------- #
# Traitements sur champ "Call" de l'objet "PTH"                         #
# Le traitement des actions "Gosub" se trouvent dans le SUBPTHA         #
# Les autres traitements se trouvent dans le SUBPTHB                    #
# Les traitements concernant la sous-traitance sont dans le SUBPTHC     #
# Les traitements de picking sont dans le TRTACHPIC1                    #
#########################################################################
$ACTION
Case ACTION
 When "DEFTRANS"     : Gosub DEFTRANS        From SUBPTHA
 When "VARIANTE"     : Gosub VARIANTE        From SUBPTHA
 When "SETTRANS"     : Gosub SETTRANS        From SUBPTHA
 When "AVANT_OUVRE"  : Gosub AVANT_OUVRE     From SUBPTHA
 When "OUVRE"        : Gosub OUVRE           From SUBPTHA
 When "OUVRE_BOITE"  : Gosub OUVRE_BOITE     From SUBPTHA
 When "AFFMASK"      : Gosub AFFMASK         From SUBPTHA
 When "SETBOUT"      : Gosub SETBOUT         From SUBPTHA
 When "AVANTBOUT"    : Gosub AVANTBOUT       From SUBPTHA
 When "STATUT"       : Gosub STATUT          From SUBPTHA
 When "EXEBOUT"      : Gosub EXEBOUT         From SUBPTHA
 When "HINT"         : Gosub HINTCLE         From SUBPTHA
 When "FILGAUCHE"    : Gosub FILGAUCHE       From SUBPTHA
 When "AP_FILGAUCHE" : Gosub AP_FILGAUCHE    From SUBPTHA
#When "TIROIR"       : Gosub TIROIR          From SUBPTHA
 When "DEB_PICK"     : Gosub DEB_PICK        From SUBPTHA
 When "PICKE"        : Gosub PICKE           From SUBPTHA
 When "DEPICK"       : Gosub DEPICK          From SUBPTHA
 When "FIN_PICK"     : Gosub FIN_PICK        From SUBPTHA
 When "APRES_MODIF"  : Gosub APRES_MODIF     From SUBPTHA
 When "GRISE"        : Gosub GRISE           From SUBPTHA
 When "FILTRE"       : Gosub FILTRE          From SUBPTHA
 When "LIENS"        : Gosub LIENS           From SUBPTHA
 When "LIENS_LIG"    : Gosub LIENS_LIG       From SUBPTHA
 When "AV_IMPRIME"   : Gosub AV_IMPRIME      From SUBPTHA
 When "AP_IMPRIME"   : Gosub AP_IMPRIME      From SUBPTHA
 When "DEFLIG"       : Gosub DEFLIG          From SUBPTHA
 When "VALLIG"       : Gosub VALLIG          From SUBPTHA
 When "RAZCRE"       : Gosub RAZCRE          From SUBPTHA
 When "VERIF_CRE"    : Gosub VERIF           From SUBPTHA
 When "INICRE"       : Gosub INICRE          From SUBPTHA
 When "INICRE_LIG"   : Gosub INICRE_LIG      From SUBPTHA
 When "CREATION"     : Gosub CREATION        From SUBPTHA
 When "ABANDON"      : Gosub ABANDON         From SUBPTHA
 When "APRES_CRE"    : Gosub APRES_CRE       From SUBPTHA
 When "AB_CREATION"  : Gosub AB_CREATION     From SUBPTHA
 When "AVANT_MOD"    : Gosub AVANT_MOD       From SUBPTHA
 When "AVANT_MODFIC" : Gosub AVANT_MODFIC    From SUBPTHA
 When "INIMOD"       : Gosub INIMOD          From SUBPTHA
 When "MODIF"        : Gosub MODIF           From SUBPTHA
 When "INIMOD_LIG"   : Gosub INIMOD_LIG      From SUBPTHA
 When "VERIF_MOD"    : Gosub VERIF           From SUBPTHA
 When "APRES_MOD"    : Gosub APRES_MOD       From SUBPTHA
 When "AB_MODIF"     : Gosub AB_MODIF        From SUBPTHA
 When "VERF_ANU"     : Gosub VERF_ANU        From SUBPTHA
 When "ANNULE"       : Gosub ANNULE          From SUBPTHA
 When "AP_ANNULE"    : Gosub AP_ANNULE       From SUBPTHA
 When "FIN_ACTION"   : Gosub FIN_ACTION      From SUBPTHA
 When "FERME"        : Gosub FERME           From SUBPTHA
#---------------------------#
# Actions champs modèlisées #
#---------------------------#
 When "AB1_NBLIG"    : Gosub AB1_NBLIG
 When "BB1_NBLIG"    : Gosub BB1_NBLIG
 When "AB2_NBLIG"    : Gosub AB2_NBLIG
 When "BB2_NBLIG"    : Gosub BB2_NBLIG
 When "AB5_NBLIG"    : Gosub AB5_NBLIG
 When "BB5_NBLIG"    : Gosub BB5_NBLIG
 When "AB6_NBLIG"    : Gosub AB6_NBLIG # Issue 84130 - 2013-03-21 by SR : Landed cost
 When "AB11_NBLIG"   : Gosub AB11_NBLIG # Issue X3-38615 - 2017-08-09 by MUARN : modif quantité sst
 When "BB11_NBLIG"   : Gosub BB11_NBLIG # Issue X3-38615 - 2017-08-09 by MUARN : modif quantité sst
 When "AB12_NBLIG"   : Gosub AB12_NBLIG
 When "BB12_NBLIG"   : Gosub BB12_NBLIG
 When "AB13_NBLIG"   : Gosub AB13_NBLIG
 When "AB14_NBLIG"   : Gosub AB13_NBLIG
 When "AAPRES_NBLIG" : Gosub AAPRES_NBLIG From SUBPTH
 When "BAPRES_NBLIG" : Gosub BAPRES_NBLIG From SUBPTH
 When "AB1_POHNUM"   : Gosub AB1_POHNUM
 When "BB1_POHNUM"   : Gosub BB1_POHNUM
 When "AB2_ITMREF"   : Gosub AB2_ITMREF
 When "BB2_ITMREF"   : Gosub BB2_ITMREF
 When "AB1_ITMDES"   : Gosub AB1_ITMDES
 When "BB1_ITMDES"   : Gosub BB1_ITMDES
 When "AB1_ITMDES1"  : Gosub AB1_ITMDES
 When "BB1_ITMDES1"  : Gosub BB1_ITMDES
 When "AB1_LOC"      : Gosub AB1_LOC
 When "BB1_LOC"      : Gosub BB1_LOC
 When Default
Endcase
Return


#######################################################################
###################      ACTIONS CHAMPS       #########################
#######################################################################

Subprog AM_PRHFCY(VALEUR)
#-----------------------------------------#
# Après modification du site de réception #
#-----------------------------------------#
Variable Char    VALEUR()

GFCY=VALEUR : Gosub CHARG_PARAM From SUBPTHB
If GMESSAGE<>""
  Local Char WMESS(80) : [L]WMESS=GMESSAGE
  GERR=1
  GFCY=[M:PTH0]PRHFCY : Gosub CHARG_PARAM From SUBPTHB
  GMESSAGE=WMESS
  mkstat=1 : End
Endif
# Issue 71069 - 2013-08-23 by SR : PJT
# A faire avant tout le reste
If GPJTSNGDOC = G_NON Then
 Call PJT_MODFCY(VALEUR,"[M:PTH1]PJT") From TRTPJT
Endif
#----- Chargement des clients correspondant au site de réception -----#
Local Integer I
Raz I, [M:PTH0]BPCORD
For [BPD] BPD1 Where RCPFCY=VALEUR
  [M:PTH0]BPCORD(I)=[F:BPD]BPCNUM
  I+=1
  If I>9  Break : Endif
Next
# Issue 107136 - 2015-03-24 by SR
#----- Contrôle et chargement des zones inter-sites -----#
If [M:PTH0]BPSNUM<>"" & [M:PTH0]BETFCY<>0
  Local Char    WBPSNUM(GLONBPS) : [L]WBPSNUM=[M:PTH0]BPSNUM
  Local Libelle WORI             : [L]WORI=1
  Local Char    WPRHFCY(GLONFCY) : [L]WPRHFCY = VALEUR
  Local Char    WPOHFCY(GLONFCY)
  Gosub CTRL_INTERSITE
  If mkstat
     Local Char WMESS(80) : WMESS=GMESSAGE
     GFCY=VALEUR : Gosub CHARG_PARAM From SUBPTHB
     GMESSAGE=WMESS
     GERR=1 : mkstat=1 : End
  Endif
Endif
# End issue 107136
#-----
[M:PTH2]DSPWEU=GSALDSPWEU
[M:PTH2]DSPVOU=GSALDSPVOU
#-----
Raz [M:PTH0]SRGLOCDEF : Affzo [PTH0]SRGLOCDEF
#----- Réinitialisation tableau des sections entête -----#
If dim([M:PTH0]NBAXE)>0 & [M:PTH0]NBAXE>0
  [M:PTH0]PRHFCY=VALEUR
  # Issue 74433 - 2011-06-20 by VPO : pb code activité ANA désactivé & GOPTCANA=0
  #Raz [M:PTH0]NBAXE, [M:PTH0]DIE, [M:PTH0]CCE
  Raz [M:PTH0]NBAXE
  If dim([M:PTH0]DIE)>0 : Raz [M:PTH0]DIE : Endif
  If dim([M:PTH0]CCE)>0 : Raz [M:PTH0]CCE : Endif
  Call INIT_CCEH("PTH0","NBAXE","PTH") From TRTX3CPT
Endif
#----- Si changement de société -----#
If GSOC_UPDFLG
  If [M:PTH0]BPSNUM<>"" & [M:PTHC]BPSINV<>""
    Call INIT_ESCOMPTE([M:PTHC]BPSINV,GSOCIETE,"F",[M:PTHC]DEP) From CPTSUB
    Call AM_DEP([M:PTHC]DEP) From SUBPTH9
  Endif
Endif
#-----
Gosub AFF_TITCOL From SUBPTHA
If GLOCARGNUM  Actzo [PTH1]5  Else  Grizo [PTH1]5 : Endif

#--- Bug 65478
If dim([M:PTH0]WRHE)>0
   Call WRHINIT([M:PTH0]WRHE,VALEUR,1) From STKWRH
Endif
#---
# Actzo ou Grizo des dépôts selon le site
[M]PRHFCY=VALEUR
Gosub WRH_ETAT From SUBPTHA
# Issue 71069 - 2013-08-23 by SR : PJT
# A faire après tout le reste
If GPJTSNGDOC = G_OUI Then
 Call PJT_MODFCY(VALEUR,"[M:PTH1]PJT") From TRTPJT
Endif
End

# Issue 107136 - 2015-03-26 by SR : Zone simplement affichée
# Issue 111491 - 2015-10-05 by SR : Utilisé en saisie des critères et en picking, donc à conserver même si la zone
# n'est plus saisissable directement
# Used in entry criteria and picking, so keep this code, even if the field is no longer directly perceptible
Subprog AM_BETFCY(VALEUR)
##---------------------------------#
## Après modif du code inter-sites #
##---------------------------------#
Variable Integer VALEUR
Local    Integer OK
[M:PCOW]WBETFCY=VALEUR
If [M:PTH0]BPSNUM<>""
  If [F:BPR]BPRNUM<>[M:PTH0]BPSNUM
    Read [BPR] BPR0=[M:PTH0]BPSNUM : If fstat  Raz [F:BPR] : Endif
  Endif
Else
  Raz [F:BPR]
Endif
If VALEUR=2
  Raz [M:PCOW]WPOHNUM, [M:PCOW]WITMREFBPS, [M:PCOW]WITMDESBPS, [M:PCOW]WVCRNUMORI
  If [F:BPR]FCY=""
    [M:PTH0]BETCPY=1 : GCPY=""
    Raz [M:PTH0]BPSNUM, [M:PTH0]SALFCY, [M:PCOW]WBPSNUM, [M:PCOW]WBPSNAM
  Else
    If find([F:BPR]FCY,GSITE(1..GNBSITE))
      GCPY=GSOCSITE(find([F:BPR]FCY,GSITE(1..GNBSITE)))
    Else
      GCPY=""
    Endif
    If GCPY<>"" & GCPY<>GSOCIETE
      [M:PTH0]BETCPY=2
    Else
      [M:PTH0]BETCPY=1
    Endif
    [M:PTH0]SALFCY=[F:BPR]FCY
  Endif
Else
  [M:PTH0]BETCPY=1 : GCPY="" : Raz [M:PTH0]SALFCY
Endif
##----- Compteurs réception -----#
If [F:TCA]MODULE<>6 | [F:TCA]CPY<>GSOCIETE
  Call LECTCA(6,OK) From SUBTCA
  If fstat | !OK  Raz [F:TCA] : Endif
Endif
##----- Si erreur de lecture on garde ce qui a été chargé dans $OUVRE -----#
If [F:TCA]MODULE=6
  If VALEUR=2 & [M:PTH0]BETCPY=1
    GMANCOU=[F:TCA]MANCOU(12) : GCODNUM=[F:TCA]CODNUM(12) : # Inter-sites/intra-soc
  Else
    GMANCOU=[F:TCA]MANCOU(5)  : GCODNUM=[F:TCA]CODNUM(5)  : # Réceptions classiques
  Endif
Endif
##-----
Affzo [PTH0]BETCPY, BPSNUM
End
# End issue 107136
# End issue 111491

Subprog AS_PTHNUM(VALEUR)
#---------------------------#
# Avant saisie n° réception #
#---------------------------#
Variable Char     VALEUR
#-- En import on autorise la saisie du numéro afin de savoir ce que l'on veut faire
If GIMPORT  End : Endif
If GREP="C" | GREP="D"
  If GMANCOU<>2
    mkstat=2
  Else
    Raz GBOUTS
  Endif
Endif
End

Subprog C_PTHNUM(VALEUR)
#-------------------------#
# Contrôle sur numéro RCP #
#-------------------------#
Variable Char     VALEUR
#-------- "Compteur manuel, saisie obligatoire !" --------#
# If GMANCOU=2 & VALEUR="" GMESSAGE=mess(182,199,1) : mkstat=1 : End : Endif
#----- Vérif si un enregistrement existe
Look [PTH] PTH0=VALEUR
#----- En import si le numéro existe c'est que l'on veut supprimer -----#
#----- Sinon c'est que l'on veut créer
If GIMPORT
  If !fstat
    GREP="A"
    Diszo [PTH0]RCPDAT, BPSNUM, BPSNDE, NDEDAT, CUR, CHGTYP, SRGLOCDEF
  Elsif GMANCOU<>2
    Raz VALEUR
  Endif
  End
Endif
#----- Vérif si un enregistrement existe (dupli non autorisée) -----#
If GREP="" & fstat
  GMESSAGE=VALEUR-mess(178,199,1) : mkstat=1 : VALEUR=[M:PTH0]PTHNUM : End
Endif
#----- En création ou dupli et cteur manuel, contrôle si no existe déja -----#
If (GREP<>"C" & GREP<>"D") | GMANCOU<>2 End : Endif
VALEUR=vireblc(VALEUR,2)
Look [PTH] PTH0=VALEUR
#-- "Fiche déjà existante"
If !fstat  GMESSAGE=mess(22,100,1) : mkstat=1 : End : Endif
End

Subprog IB_BPSNUM
#---------------------------------#
# Initialisation du bouton BPSNUM #
#---------------------------------#
Raz GBOUT2, GBOUT3, GBOUT4
If [M:PTH0]BPSNUM=""  Raz GBOUT5 : Endif
End

Subprog AM_BPSNUM(VALEUR)
#--------------------#
# Après-modif BPSNUM #
#--------------------#
Variable Char    VALEUR()
Local    Integer  I, OK

If VALEUR<>""
  #----- Lecture BPSUPPLIER si nécessaire -----#
  If [F:BPS]BPSNUM<>VALEUR
    Read [BPS] BPS0=VALEUR : If fstat  Raz [F:BPS] : mkstat=1 : End : Endif
  Endif
  #----- Lecture BPARTNER si nécessaire -----#
  If [F:BPR]BPRNUM<>VALEUR
    Read [BPR] BPR0=VALEUR : If fstat  Raz [F:BPR] : mkstat=1 : End : Endif
  Endif
  #-----
  [M:PTH0]VACBPR=[F:BPS]VACBPR
  [M:PTH0]CHGTYP=[F:BPS]CHGTYP
  [M:PTH0]CUR   =[F:BPS]CUR
  #----- Ecran complément -----#
  [M:PTHC]BPTNUM=[F:BPS]BPTNUM
  [M:PTHC]MDL   =[F:BPS]MDL
  If [F:BPS]BPRPAY=""
    [M:PTHC]BPRPAY=VALEUR
    [M:PTHC]BPAPAY=[F:BPS]BPAADD
  Else
    [M:PTHC]BPRPAY=[F:BPS]BPRPAY
    [M:PTHC]BPAPAY=[F:BPS]BPAPAY
  Endif
  If [F:BPS]BPSINV=""
    [M:PTHC]BPSINV=VALEUR
    [M:PTHC]BPAINV=[F:BPS]BPAADD
  Else
    [M:PTHC]BPSINV=[F:BPS]BPSINV
    [M:PTHC]BPAINV=[F:BPS]BPAINV
  Endif
  #----- Ecran adresse fournisseur expéditeur -----#
  If [M:AD68]ADBFLG>0 & [M:PTH0]BPSNUM<>""  Raz [M:AD68] : Endif
  [M:AD68]BPAADD = [F:BPS]BPAADD
  [M:AD68]ADBBPR = [F:BPS]BPSNUM
  #----- Ecran informations douanières -----#
  [M:PCEX]EECICT =[F:BPS]EECICT    : # Incoterm
  [M:PCEX]WPOSCOD=""
  [M:PCEX]WBPSNUM=VALEUR
  [M:PCEX]WBPAADD=[F:BPS]BPAADD
  [M:PCEX]WCRY   =""
  If GACTDEB=2
    # [M:PCEX]EECNAT = "11"                     :# CPO 07/2008 - initialisé dans INICRE
    # If GDEBGBR=1  [M:PCEX]EECNAT="10" : Endif :# CPO 07/2008 - initialisé dans INICRE
    # [M:PCEX]EECSCH = "11"                     :# CPO 07/2008 - initialisé dans INICRE
    [M:PCEX]EECLOC=[F:BPS]EECLOC  : # Lieu de transport CEE
    #----- Lecture table des modes de livraison si nécessaire -----#
    If [F:TMD]MDL<>[F:BPS]MDL
      Read [TMD] TMD0=[F:BPS]MDL : If fstat  Raz [F:TMD] : Endif
    Endif
    [M:PCEX]EECTRN=[F:TMD]EECTRN  : # Mode de transport CEE
    If [F:BPR2]BPRNUM<>[F:BPS]BPSINV
      Read [BPR2] BPR0=[F:BPS]BPSINV : If fstat  Raz [F:BPR2] : Endif
    Endif
    [M:PCEX]EECNUM=[F:BPR2]EECNUM : # Identification CEE
  Endif
Else
  Raz [F:BPS], [F:BPR]
Endif
#----- Chargement pour l'inter-sites -----#
 # Issue 107136 - 2015-03-24 by SR
#If [F:BPR]FCY=""
#  If [F:BPR]BPRNUM<>""  [M:PTH0]BETFCY=1 : Endif
#  [M:PTH0]BETCPY=1
#  Raz [M:PTH0]SALFCY, GCPY
#Else
#  [M:PTH0]BETFCY=2
#  If find([F:BPR]FCY,GSITE(1..GNBSITE))
#    GCPY=GSOCSITE(find([F:BPR]FCY,GSITE(1..GNBSITE)))
#  Else
#    GCPY=""
#  Endif
#  If GCPY<>"" & GCPY<>GSOCIETE
#    [M:PTH0]BETCPY=2
#  Else
#    [M:PTH0]BETCPY=1
#  Endif
#  [M:PTH0]SALFCY=[F:BPR]FCY
#Endif
#----- Compteurs réception -----#
#If [F:TCA]MODULE<>6 | [F:TCA]CPY<>GSOCIETE
#  Call LECTCA(6,OK) From SUBTCA
#  If fstat | !OK  Raz [F:TCA] : Endif
#Endif
#----- Si erreur de lecture on garde ce qui a été chargé dans $OUVRE -----#
#If [F:TCA]MODULE=6
# If [M:PTH0]BETFCY=2 & [M:PTH0]BETCPY=1
#    GMANCOU=[F:TCA]MANCOU(12) : GCODNUM=[F:TCA]CODNUM(12) : # Inter-sites/intra-soc
#  Else
#    GMANCOU=[F:TCA]MANCOU(5)  : GCODNUM=[F:TCA]CODNUM(5)  : # Réceptions classiques
# Endif
#Endif
#-----
#[M:PCOW]WBETFCY=[M:PTH0]BETFCY
#[M:PCOW]WBPSNUM=VALEUR
Local Libelle WORI             : [L]WORI=2
Local Char    WPRHFCY(GLONFCY) : [L]WPRHFCY = [M:PTH0]PRHFCY
Local Char    WBPSNUM(GLONBPS) : [L]WBPSNUM = VALEUR
Local Char    WPOHFCY(GLONFCY)
Gosub CTRL_INTERSITE
If mkstat
   Local Char WMESS(80) : WMESS=GMESSAGE
   GFCY=[M:PTH0]PRHFCY : Gosub CHARG_PARAM From SUBPTHB
   GMESSAGE=WMESS
   GERR=1 : mkstat=1 : End
Endif
# End issue 107136
#-----
If VALEUR<>""
  GCUR=[F:BPS]CUR
  If [F:TCU]CUR<>GCUR
    Read [TCU] TCU0=GCUR : If fstat  Raz [F:TCU] : [F:TCU]CURRND=0.01 : Endif
  Endif
  GPTH_RND=[F:TCU]CURRND
  [M:PTH2]FMTCPLAMT=right$("-NPz:",(GREP="C")+1)+GDEVFMT1(max(find(GCUR,GDEVISE(1..GNBDEV)),1))
  #----- Escompte du tiers facturant -----#
  Call INIT_ESCOMPTE([M:PTHC]BPSINV,GSOCIETE,"F",[M:PTHC]DEP) From CPTSUB
  #----- Chargement du régime de tase du fournisseur -----#
  Call INIT_REGIME(VALEUR,[M:PTH0]PRHFCY,"F",[M:PTH0]VACBPR) From CPTSUB
  #----- Chargement du type de régime taxe -----#
  # 71937 : Multilégislation
  #If [F:ADI]NUMTAB<>1 | [F:ADI]CODE<>[M:PTH0]VACBPR
  #  Read [ADI] CODE=1;[M:PTH0]VACBPR : If fstat Raz [F:ADI] : Endif
  #Endif
  #[M:PTH0]VACTYP=[F:ADI]N1
  If !clalev([F:TVB]) Local File TABVACBPR [TVB] Endif
  Local Integer GRET
  Call LEC_TVB_LEG(GCURLEG,[M:PTH0]VACBPR,GRET) From TRTLECLEG
  If GRET Raz [F:TVB] : Endif
  [M:PTH0]VACTYP=[F:TVB]REGVAC
  # 71937 : Multilégislation

  #----- Chargement du cours devise -----#
  Call COURSITE(GCUR,GFCY,[M:PTH0]CHGTYP,[M:PTH0]RCPDAT,[M:PTH0]CHGCOE,I) From TRTDEV
  # Issue 91572 - 2013-08-01 by MUARN : si aucun cours trouvé message avertissement
  If I = 1
    GMESSAGE = mess(16,114,1) + "\" + mess(462,194,1)
    Call MESSAGE(GMESSAGE) From GESECRAN
  Endif
  #----- Chargement libellés et formats colonnes tarif -----#
  If GPLISTC<>[F:BPS]PLISTC
    GPLISTC=[F:BPS]PLISTC
    Call COLREM("C",2,[F:BPS]PLISTC) From TRTPRICE
    Call TYPREM(2,[F:BPS]PLISTC)     From TRTPRICE
    Call TARIFCHGT(6)                From TRTPRICE
    #----- Affichage entêtes de colonne variables -----#
    If !GIMPORT & !GVTMOD & (dim([M:PTH1]DISCRGVAL1)>0 | dim([M:PTH1]CCE1)>0)
      Local Char BASPAG(10) : BASPAG="NBLIG" : Gosub TIT_COL From ="W1WE6"+GPTRNUM+"1"
    Endif
  Endif
  Call FMTREM("PTH1",GCUR) From TRTPRICE
  #------ Chargement des éléments de facturation -----#
  [M:PTH0]BPSNUM=VALEUR
  Call INIT_ELEMENTS (6,[M:PTH0]CHGTYP,[F:BPS]CUR,GCUR) From TRTACHELT1
  Call AM_DEP([M:PTHC]DEP) From SUBPTH9
  Affzo [PTH2]1-99
  #----- Initialisation des sections analytiques -----#
  If dim([M:PTH0]NBAXE)>0
    # Issue 74433 - 2011-06-20 by VPO : pb code activité ANA désactivé & GOPTCANA=0
    #Raz [M:PTH0]NBAXE, [M:PTH0]DIE, [M:PTH0]CCE
    Raz [M:PTH0]NBAXE
    If dim([M:PTH0]DIE)>0 : Raz [M:PTH0]DIE : Endif
    If dim([M:PTH0]CCE)>0 : Raz [M:PTH0]CCE : Endif
    Call INIT_CCEH("PTH0","NBAXE","PTH") From TRTX3CPT
  Endif
  Actzo [PTH0]CUR
  If [M:PTH0]CUR=GLOCALDEV  Diszo [PTH0]CHGTYP Else Actzo [PTH0]CHGTYP : Endif
Endif
Affzo [PTH0]CUR, CHGTYP, BETFCY, BETCPY
If dim([M:PTH0]WRHE)>0 Affzo [PTH0]WRHE Endif
#----- Initialisations pour l'Argentine -----#
If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
  Local Integer J, STAT
  Local Char    CAI(14)
  Local Date    DATVAL
  If !clalev([F:ADI])  Local File ATABDIV [ADI] : Endif
  Raz J
  For [ADI] CODE Where NUMTAB=362
    I=instr(1,[F:ADI]A1,num$(7))
    If I
      [M:PTH1]TYPVCR   =[F:ADI]CODE
      [M:PTH1]CAI      =[F:BPS]CAI(J)
      [M:PTH1]DATVLYCAI=[F:BPS]DATVLYCAI(J)
      Call TTCSSSS(2,[F:ADI]CODE,1,[M:PTH0]PRHFCY,[0/0/0],[M:PTH0]VACBPR,[M:PTH1]TYPVCR,
&                  [M:PTH1]CLSVCR,[M:PTH1]SCUVCR,CAI,DATVAL,STAT) From SUBANMARG
      If !clalev([F:NCA])  Local File NUMCAI [NCA] : Endif
      Filter [NCA] Where CAI=[M:PTH1]CAI
&                      & TYP=[M:PTH1]TYPVCR
&                      & CLS=[M:PTH1]CLSVCR
&                      & VLYEND>=[M:PTH0]RCPDAT
&                      & FLGSHL<>2
      Read [NCA] NCA0 First : If fstat  Raz [F:NCA] : Endif
      Filter [NCA]
      [M:PTH1]SCUVCR=[F:NCA]SCU
      If [M:PTH1]SCUVCR<>""
        [M:PTH1]SCUVCR=string$(4-len([M:PTH1]SCUVCR),"0")+[M:PTH1]SCUVCR
      Endif
      [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]CLSVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR
      Affzo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR : Affzo [PTH0]BPSNDE
      If [M:PTH0]BPSNDE<>""
        Diszo [PTH0]BPSNDE
      Else
        Actzo [PTH0]BPSNDE
      Endif
      Affzo [PTH1]CAI, DATVLYCAI
      Break
    Endif
    J+=1
  Next
Endif
End

# Issue 107136 - 2015-03-24 by SR :
$CTRL_INTERSITE
Gosub CHARG_POHFCY
Local Char  WSALFCY(GLONFCY), WSTOFCY(GLONFCY), WINVFCY(GLONFCY)
Local Char  WBPCORD(GLONBPC), WBPCINV(GLONBPC)
If ! clalev([F:BPC]) : Local File BPCUSTOMER [BPC] : Endif
GRCPFCY=GFCY
Call CTRL_INTERSITE(WPOHFCY,WBPSNUM,2,[M:PTH0]BETFCY,[M:PTH0]BETCPY,[M:PTH0]SALFCY,
&                  [L]WSTOFCY,[L]WBPCORD,[L]WINVFCY,[L]WBPCINV,GBIDI3) From TRTACHCTL1
If mkstat  GERR=1 : Return : Endif
#----- Compteurs réception -----#
If [F:TCA]MODULE<>6 | [F:TCA]CPY<>GSOCIETE
  If dim(OK)<1 : Local Integer OK : Endif # Issue 112572 - 2015-11-24 by MUARN
  Call LECTCA(6,OK) From SUBTCA
  If fstat | !OK  Raz [F:TCA] : Endif
Endif
#----- Si erreur de lecture on garde ce qui a été chargé dans $OUVRE -----#
If [F:TCA]MODULE=6
  If [M:PTH0]BETFCY=2 & [M:PTH0]BETCPY=1
    GMANCOU=[F:TCA]MANCOU(12) : GCODNUM=[F:TCA]CODNUM(12) : # Inter-sites/intra-soc
  Else
    GMANCOU=[F:TCA]MANCOU(5)  : GCODNUM=[F:TCA]CODNUM(5)  : # Réceptions classiques
  Endif
Endif
[M:PCOW]WBETFCY=[M:PTH0]BETFCY
[M:PCOW]WBPSNUM=WBPSNUM
Return

#--------------------------------------------------------------------------------------#
$CHARG_POHFCY
#-------------------------------------------#
# Chargement du site de commande par défaut #
#-------------------------------------------#
Raz WPOHFCY
#----- (1) Recherche site associé au client (client livré associé au site retour) -----#
If dim(WBPSNUM)>0
   Filter [BPD] Where RCPFCY=WPRHFCY & ENAFLG=2 & BPCNUM <> WBPSNUM
Else
   Filter [BPD] Where RCPFCY=WPRHFCY & ENAFLG=2
Endif
# End issue 101566
Read [BPD] BPD1 First
If !fstat
  Read [BPR2] BPR0=[F:BPD]BPCNUM
  If !fstat & [F:BPR2]FCY<>""
    Read [FCY] FCY0=[F:BPR2]FCY
    If !fstat & [F:FCY]LEGCPY=GSOCIETE & [F:FCY]PURFLG=2
      WPOHFCY=[F:FCY]FCY
    Endif
  Endif
Endif
Filter [BPD]
#----- (2) Site de retour si celui-ci est site d'achat -----#
If WPOHFCY=""
  Read [FCY] FCY0=WPRHFCY : If fstat  Raz [F:FCY] : Endif
  If [F:FCY]PURFLG=2
    WPOHFCY=WPRHFCY
  #----- (3) Site d'achat de l'utilisateur si appartient à la même société -----#
  Elsif GFCYDEF(6)<>""
    Read [FCY] FCY0=GFCYDEF(6) : If fstat  Raz [F:FCY] : Endif
    If [F:FCY]LEGCPY=GSOCIETE & [F:FCY]PURFLG=2
      WPOHFCY=GFCYDEF(6)
    Endif
  Endif
Endif
#----- (4) 1er site d'achat appartenant à la même société -----#
If WPOHFCY=""
  Filter [FCY] Where LEGCPY=GSOCIETE & PURFLG=2
  Read [FCY] FCY1 First
  Filter [FCY]
  If fstat
    Raz [F:FCY]
  Else
    WPOHFCY=[F:FCY]FCY
  Endif
Endif
Return
# End issue 107136


Subprog C_RCPDAT(VALEUR)
#----------------------------#
# Contrôle date de réception #
#----------------------------#
Variable Date     VALEUR
#----------------------------------------------#
# date ne doit pas etre superieure à date jour #
#----------------------------------------------#
If VALEUR > date$
  mkstat = 2
  #-- "Date supérieure à la date du jour"
  GMESSAGE = mess(129,194,1)
Endif
End


Subprog AM_RCPDAT(VALEUR)
#-------------------------------#
# Après-modif date de réception #
#-------------------------------#
Variable Date     VALEUR
#----------------------------------------------#
# message info si date inférieur à date jour   #
# date ne doit pas etre superieure à date jour #
#----------------------------------------------#
If VALEUR < date$
  Call MESSAGE(mess(65,194,1))  From GESECRAN
Endif
If GREP<>"C"
  Call MESSAGE(mess(242,194,1)) From GESECRAN
Else
  #----- Controle date avec statut des périodes -----#
  If [M:PTH1]NBLIG>0
    Local Integer I, OK
    Local Char    WFCY(GLONFCY) : WFCY=[M:PTH0]PRHFCY
    Local Date    WDAT          : WDAT=VALEUR
    If sigma(I=0,[M:PTH1]NBLIG-1,[M:PTH1]STOMGTCOD(I)>1)
      Call STKCTRIPT(WDAT,WFCY,"1") From  STKLIB
      If GERR=2
        OK=1 : Call AVERTIR(GMESSAGE,OK) From GESECRAN
        If OK=1
          Raz GMESSAGE, GERR : mkstat=1
        Else
          Raz GMESSAGE, GERR : mkstat=0
        Endif
      Elsif GERR=1 | mkstat=2
        GERR=1 : mkstat=1
      Endif
    Endif
  Endif
  #-----
Endif
#--- Contrôle date entrée par rapport aux dates mouvements en attente
If GREP="C" & [M:PTH1]NBLIG>0  & !GVTMOD  # hcb 64182
  Local Integer I
  Local Date    LDATRUP, LDAT
  Local Decimal LQTYRUP
  Local Char WMESS(250) : WMESS=""
  For I=0 To [M]NBLIG-1
    # Issue 94755 GA 12/2013 pas de message si composant fourni par le sous-traitant
    #--- Contrôle date entrée par rapport aux dates mouvements en attente
    If [M:PTH1]STOMGTCOD(I)>1 & [M:PTH1]LINTYP(I)<3
       #--- Bug 69674
       #Call CTLRUP([M]PRHFCY,[M]ITMREF(I),VALEUR,1,LDATRUP,LQTYRUP) From STKLIB
       Call CTLRUP([M:PTH0]PRHFCY,[M:PTH1]ITMREF(I),VALEUR,0,LDATRUP,LQTYRUP) From STKLIB
       #---
        If LDATRUP<>[0/0/0]
           If LDAT<LDATRUP LDAT=LDATRUP Endif
           If WMESS=""  WMESS="("+[M:PTH1]ITMREF(I)
           Elsif len(WMESS)<200
                        WMESS+=","+[M:PTH1]ITMREF(I)
           Endif
        Endif
    Endif
  Next I
  If LDAT<>[0/0/0]
    If WMESS<>"" WMESS+=",...)" Endif
    Call MESSAGE(mess(354,184,1)-":\"+mess(355,184,1)-format$("DD2",LDAT)+
&                "\"+mess(357,184,1)-format$("DD2",LDAT)+"\"+WMESS) From GESECRAN
  Endif
Endif
#---
##VPO 07/01/11 70362 en creation la modif de la date peut entrainer la modif des CPR
If GREP="C" & GCUR<>""
    Local    Integer  I
    Local    Char     OLDCUR(GLONCUR) : OLDCUR=[M:PTH0]CUR
    [M:PTH0]RCPDAT = VALEUR
    Call COURSITE(GCUR,GFCY,[M:PTH0]CHGTYP,[M:PTH0]RCPDAT,[M:PTH0]CHGCOE,I) From TRTDEV
    If !GIMPORT Affzo [M:PTH0]CHGCOE : Endif
Endif

[M:PTH0]RCPDAT=VALEUR
For K=0 To [M:PTH1]NBLIG-1
 Call AM_RCPDAT(K) From TWMLIB  # Three way matching GRNA
Next
End

Subprog AM_BPSNDE(VALEUR)
#-----------------------------------------------#
# Contrôle numéro de Bl fournisseur existe déjà #
#-----------------------------------------------#
Variable Char    VALEUR()
Local    Integer OK
If VALEUR<>""
  If [M:PTH0]BPSNUM=""
    Filter [PTH] Where BPSNDE=VALEUR
  Else
    Filter [PTH] Where BPSNDE=VALEUR & BPSNUM=[M:PTH0]BPSNUM
  Endif
  Look [PTH] PTH1 First
  Filter [PTH]
  If !fstat
    OK=2 : Call AVERTIR(mess(207,194,1),OK) From GESECRAN
    If OK=1 mkstat=1 : End : Endif
  Endif
Endif
[M:PTH0]BPSNDE2=VALEUR
End

Subprog AM_NDEDAT(VALEUR)
#---------------------------------#
# Après modif date BL fournisseur #
#---------------------------------#
Variable Date    VALEUR()
[M:PTH0]NDEDAT2=VALEUR
End

Subprog C_CUR(VALEUR)
#-----------------#
# Contrôle devise #
#-----------------#
Variable Char    VALEUR()
If VALEUR="" & [M:PTH0]BPSNUM<>""
  GMESSAGE=mess(10,123,1) : mkstat=1 : # Zone obligatoire !
Endif
End

Subprog AM_CUR(VALEUR)
#--------------------------------------#
#          Après modif devise          #
# ------------------------------------ #
# Chargement et affichage cours devise #
# Conversion éléments de facturation   #
#--------------------------------------#
Variable Char     VALEUR
Local    Integer  I
Local    Char     OLDCUR(GLONCUR) : OLDCUR=[M:PTH0]CUR
GCUR=VALEUR
If [F:TCU]CUR<>GCUR
  Read [TCU] TCU0=GCUR : If fstat  Raz [F:TCU] : [F:TCU]CURRND=0.01 : Endif
Endif
GPTH_RND=[F:TCU]CURRND
Call COURSITE(GCUR,GFCY,[M:PTH0]CHGTYP,[M:PTH0]RCPDAT,[M:PTH0]CHGCOE,I) From TRTDEV
# Issue 91572 - 2013-08-01 by MUARN : si aucun cours trouvé message avertissement
If I = 1
  GMESSAGE = mess(16,114,1) + "\" + mess(462,194,1)
  Call MESSAGE(GMESSAGE) From GESECRAN
Endif
If !GIMPORT Affzo [PTH0]CHGCOE : Endif
#----- Conversion Mts éléments de facturation -----#
Call CONVERT_MONTANT(VALEUR,[M:PTH0]CHGTYP) From SUBPTHD
#----- Chargement formats colonnes tarif -----#
Call FMTREM("PTH1",GCUR) From TRTPRICE
[M:PTH2]FMTCPLAMT=right$("-NPz:",(GREP="C")+1)+GDEVFMT1(max(find(GCUR,GDEVISE(1..GNBDEV)),1))
#-----
If VALEUR=GLOCALDEV Diszo [PTH0]CHGTYP Else Actzo [PTH0]CHGTYP : Endif
#-----
If [M:PTH1]NBLIG>0  [M:PTH0]CUR=VALEUR : Gosub RECALCUL_LIGNES : Endif
#-----
If !GIMPORT  Affzo [PTH2]1-99 : Endif
End

$RECALCUL_LIGNES
#---------------------------------------------------------------------------#
# Si des lignes de réceptions existent, il faut les convertir et recalculer #
#---------------------------------------------------------------------------#
If [M:PTH1]NBLIG>0
  # Issue 92594 - 2013-09-13 by MUARN : en picking NBLIG non renseigné travailler avec nolign-1
  For I=0 To max(nolign-1,[M:PTH1]NBLIG-1)
    Call MAJ_CUMULS_LIG(I,-2) From SUBPTHD
    Call MAJ_BASTAX_LIG(I,-1) From SUBPTHD
    Call CONVERSION(OLDCUR,I) From SUBPTHB
    [M:PTH1]NETCUR(I)=[M:PTH0]CUR
    [M:PTH1]LINAMT(I)=[M:PTH1]NETPRI(I)*[M:PTH1]QTYUOM(I)
    Call ARRDEV([M:PTH1]LINAMT(I),[M:PTH0]CUR) From TRTDIV
    Call MAJ_CALTAX_LIG("PTH1",I) From TRTACHDIV1
    Call MAJ_BASTAX_LIG(I,+1) From SUBPTHD
    Call MAJ_CUMULS_LIG(I,+2) From SUBPTHD
    [M:PTH1]UPDFLG(I)=1
  Next I
Endif
If GPIHCALTAX=2 | (dim([M:PTH2]DISVATFLG)>0 & find(2,[M:PTH2]DISVATFLG(0..[M:PTH2]NBFAC-1)))
  For GPTH_INDTAX=1 To [M:PTH2]NBTAX
    Gosub CAL_TAXE_GLOB From SUBPTHD
  Next GPTH_INDTAX
Endif
If !GIMPORT  Affzo [PTH1]10 : Endif
Return

Subprog AM_CHGTYP(VALEUR)
#--------------------------------------#
#      Après modif type de cours       #
# ------------------------------------ #
# Chargement et affichage cours devise #
# Conversion éléments de facturation   #
#--------------------------------------#
Variable Integer  VALEUR
Local    Integer  I
Local    Char     OLDCUR(GLONCUR) : OLDCUR=[M:PTH0]CUR
Call COURSITE(GCUR,GFCY,VALEUR,[M:PTH0]RCPDAT,[M:PTH0]CHGCOE,I) From TRTDEV
# Issue 91572 - 2013-08-01 by MUARN : si aucun cours trouvé message avertissement
If I = 1
  GMESSAGE = mess(16,114,1) + "\" + mess(462,194,1)
  Call MESSAGE(GMESSAGE) From GESECRAN
Endif
If !GIMPORT Affzo [PTH0]CHGCOE : Endif
#----- Conversion Mts éléments de facturation -----#
Call CONVERT_MONTANT([M:PTH0]CUR,VALEUR) From SUBPTHD
#-----
If [M:PTH1]NBLIG>0  [M:PTH0]CHGTYP=VALEUR : Gosub RECALCUL_LIGNES : Endif
#-----
If !GIMPORT  Affzo [PTH2]1-99 : Endif
End

Subprog AS_WRHE(VALEUR)
Variable Char    VALEUR()
If GWRHOBY=2 & VALEUR<>"" & [M]NBLIG<>0
   GMESSAGE=mess(342,184,1) : mkstat=2
Endif
End

Subprog AM_VACBPR(VALEUR)
#----------------------------------------------------------#
# Après modif régime taxe : Réactualisation des codes taxe #
#----------------------------------------------------------#
Variable Char  VALEUR()
Local Shortint I
Local Libelle  WVACTYP_NEW, WVACTYP_OLD
Local Char     WVAT(GLONVAT)
#----- Chargement du type de régime taxe -----#
# 71937 : Multilégislation
#If [F:ADI]NUMTAB<>1 | [F:ADI]CODE<>VALEUR
# Read [ADI] CODE=1;VALEUR : If fstat Raz [F:ADI] : Endif
#Endif
#WVACTYP_NEW=[F:ADI]N1
If !clalev([F:TVB]) Local File TABVACBPR [TVB] Endif
Local Integer GRET
Call LEC_TVB_LEG(GCURLEG,VALEUR,GRET) From TRTLECLEG
If GRET Raz [F:TVB] : Endif
WVACTYP_NEW=[F:TVB]REGVAC
# 71937 : Multilégislation

WVACTYP_OLD=[M:PTH0]VACTYP
#-----
If [M:PTH1]NBLIG>0
  # Issue 92594 - 2013-09-13 by MUARN : en picking NBLIG non renseigné travailler avec nolign-1
  For I=0 To max(nolign-1,[M:PTH1]NBLIG-1)
    Call MAJ_CUMULS_LIG(I,-1) From SUBPTHD : # Màj cumuls et éléments
    Call MAJ_BASTAX_LIG(I,-1) From SUBPTHD : # Màj bases et mts taxe
  Next I
Endif
[M:PTH0]VACBPR=VALEUR
[M:PTH0]VACTYP=WVACTYP_NEW
For I=0 To dim([M:PTH1]INVDTAVAT1)-1
  Read [PFI] PFI0=GINVDTALIN(I) : If fstat Raz [F:PFI] : Endif
  If [F:PFI]VATRUL=2
    If !clalev([F:TVC])  Local File TABVAC [TVC] : Endif
    Call RECHVATFOOT(2,[M:PTH0]BPSNUM,[F:PFI]PFINUM,"PTH2",WVAT) From TRTX3
    [M:PTH1]INVDTAVAT1(I)=WVAT
  Endif
Next I
If [M:PTH1]NBLIG>0
  # Issue 92594 - 2013-09-13 by MUARN : en picking NBLIG non renseigné travailler avec nolign-1
  For I=0 To max(nolign-1,[M:PTH1]NBLIG-1)
    If [F:ITM]ITMREF<>[M:PTH1]ITMREF(I)
      Read [ITM] ITM0=[M:PTH1]ITMREF(I) : If fstat Raz [F:ITM] : Endif
    Endif
    Call ALIVATCOD(2,[M:PTH0]BPSNUM,[M:PTH1]ITMREF(I),"PTH1",I) From TRTX3
    Call MAJ_CALTAX_LIG("PTH1",I) From TRTACHDIV1
    Call MAJ_BASTAX_LIG(I,+1) From SUBPTHD : # Màj bases et mts taxe
    Call MAJ_CUMULS_LIG(I,+1) From SUBPTHD : # Màj cumuls et éléments
    [M:PTH1]UPDFLG(I)=1
  Next I
Endif
For I=0 To [M:PTH2]NBFAC-1
  [M:PTH0]VACTYP=WVACTYP_OLD
  Call MAJ_ELEMENT (I,1,-1) From SUBPTHD
  [M:PTH0]VACTYP=WVACTYP_NEW
  Read [PFI] PFI0=[M:PTH2]INVDTA(I) : If fstat Raz [F:PFI] : Endif
  If [F:PFI]VATRUL=2
    If !clalev([F:TVC])  Local File TABVAC [TVC] : Endif
    Call RECHVATFOOT(2,[M:PTH0]BPSNUM,[F:PFI]PFINUM,"PTH2",WVAT) From TRTX3
    [M:PTH2]INVDTAVAT(I)=WVAT
  Endif
  Call MAJ_ELEMENT (I,0,+1) From SUBPTHD
Next I
If GPIHCALTAX=2 | (dim([M:PTH2]DISVATFLG)>0 & find(2,[M:PTH2]DISVATFLG(0..[M:PTH2]NBFAC-1)))
  For GPTH_INDTAX=1 To [M:PTH2]NBTAX
    Gosub CAL_TAXE_GLOB From SUBPTHD
  Next GPTH_INDTAX
Endif
Raz [M:PTH1]CLCFLG
If !GIMPORT  Affzo [PTH1]10 : Affzo [PTH2]1-99 : Endif
End

Subprog AM_TYPVCR(VALEUR)
#----------------------------------------#
# Après modification du type de document #
#----------------------------------------#
Variable Char    VALEUR()
If VALEUR=""
  If [M:PTH1]CLSVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR<>""
    [M:PTH0]BPSNDE=[M:PTH1]CLSVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR
    Affzo [PTH0]BPSNDE
  Else
    Actzo [PTH0]BPSNDE
    Effzo [PTH0]BPSNDE
  Endif
Else
  [M:PTH0]BPSNDE=VALEUR+[M:PTH1]CLSVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR
  Affzo [PTH0]BPSNDE
  Diszo [PTH0]BPSNDE
  Call AM_BPSNDE([M:PTH0]BPSNDE)
Endif
End

Subprog AM_CLSVCR(VALEUR)
#---------------------------------#
# Après modification de la classe #
#---------------------------------#
Variable Char    VALEUR()
If VALEUR=""
  If [M:PTH1]TYPVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR<>""
    [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR
    Affzo [PTH0]BPSNDE
  Else
    Actzo [PTH0]BPSNDE
    Effzo [PTH0]BPSNDE
  Endif
Else
  [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+VALEUR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR
  Affzo [PTH0]BPSNDE
  Diszo [PTH0]BPSNDE
  Call AM_BPSNDE([M:PTH0]BPSNDE)
Endif
End

Subprog AM_SCUVCR(VALEUR)
#-------------------------------------#
# Après modification de la succursale #
#-------------------------------------#
Variable Char    VALEUR()
If VALEUR=""
  If [M:PTH1]TYPVCR+[M:PTH1]CLSVCR+[M:PTH1]SEQVCR<>""
    [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]CLSVCR+[M:PTH1]SEQVCR
    Affzo [PTH0]BPSNDE
  Else
    Actzo [PTH0]BPSNDE
    Effzo [PTH0]BPSNDE
  Endif
Else
  VALEUR=string$(4-len(VALEUR),"0")+VALEUR : # Ajout zéros à gauche
  [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]CLSVCR+VALEUR+[M:PTH1]SEQVCR
  Affzo [PTH0]BPSNDE
  Diszo [PTH0]BPSNDE
  Call AM_BPSNDE([M:PTH0]BPSNDE)
Endif
End

Subprog AM_SEQVCR(VALEUR)
#-----------------------------------------#
# Après mdification du numéro de séquence #
#-----------------------------------------#
Variable Char    VALEUR()
If VALEUR=""
  If [M:PTH1]TYPVCR+[M:PTH1]SCUVCR+[M:PTH1]CLSVCR<>""
    [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]SCUVCR+[M:PTH1]CLSVCR
    Affzo [PTH0]BPSNDE
  Else
    Actzo [PTH0]BPSNDE
    Effzo [PTH0]BPSNDE
  Endif
Else
  VALEUR=string$(8-len(VALEUR),"0")+VALEUR : # Ajout zéros à gauche
  [M:PTH0]BPSNDE=[M:PTH1]TYPVCR+[M:PTH1]CLSVCR+[M:PTH1]SCUVCR+VALEUR
  Affzo [PTH0]BPSNDE
  Diszo [PTH0]BPSNDE
  Call AM_BPSNDE([M:PTH0]BPSNDE)
Endif
End

Subprog IB_NBLIG
#----------------------------------#
# Initialisation des boutons       #
# -------------------------------- #
# B1  Tunnel commande              #
# B2  Saisie du detail             #
# B3  Info du lot                  #
# B4  Complément lot               #
# B5  Modif de stock               #
# B6  Détail SDC                   #
# B7  Affichage détail qtés        #
# B8  Texte                        #
# B9  Solde de ligne               #
# B10 Explication du prix          #
# B11 Saisie sous-traitance OF     #
# B12 Pièce d'origine              #
# B13 Plan de production   - GPAO  #
# B14 Plan de consommation - GPAO  #
# B15 Saisie sous-traitance SCO    #
# B16 Stock par site               #
# B17 Détail valorisation          #
# B18 Traçabilité pièces           #
#----------------------------------#
Local Integer  C, WRETOUR,WSTOMGTCOD
Local Shortint NOL : NOL=nolign-1
Raz GBOUT1, GBOUT7, GBOUT8, GBOUT9, GBOUT10, GBOUT12,GBOUT6

# Call IB_NOTECHECK([M:PTH1]ITMREF,"ITMREF",20) From TRTNTSCTL # product notes  EWI 86291

If [M:PTH1]NBLIG>0 & NOL<=dim([M:PTH1]ITMREF)-1 & [M:PTH1]ITMREF(NOL)<>""
  # Issue 84130 - 2012-12-21 by SR : Landed cost Seulement si pas en cours de création/Modif, etc ...
  If GREP = "" : GBOUT17=mess(497,198,1) : Endif
  # Issue 84130 - 2012-12-07 by SR : Bouton Détail SDC
  If [M:PTH1]STCNUM(nolign-1) <> "" GBOUT6=mess(498,198,1)  : Endif
  #----- Lecture ITMMASTER si nécessaire -----#
  If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
    Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
  Endif
  #----- Lecture ITMFACILITY si nécessaire -----#
  If [F:ITF]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
    Read [ITF] ITF0=[M:PTH1]ITMREF(NOL);[M:PTH0]PRHFCY
    If fstat  Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD : Endif
  Endif
  #-----
  WSTOMGTCOD=[F:ITF]STOMGTCOD
  #-----
  If [M:PTH1]POHNUM(NOL)<>"" & GFONC1<>"GESPOH"
    GBOUT1=mess(98,197,1)-[M:PTH1]POHNUM(NOL)           : # Commande xxxxxxxxxx
  Endif
  #----- Texte ligne de réception -----#
  GBOUT8=mess(38,198,1)                                 : # Texte
  #----- Si ligne déjà enregistrée -----#
  If [M:PTH1]CREFLG(NOL)<>0
    If ([M:PTH0]BETFCY<>2 | [M:PTH0]BETCPY=2) & [M:PTH1]LINTYP(NOL)<3
      GBOUT9=mess(12,198,1)                             : # Solde
    Endif
    GBOUT7 =mess(164,198,1)                             : # Situation ligne
    If [M:PTH1]LINTYP(NOL)<>2
      GBOUT10=mess(386,198,1)                           : # Explication du prix (sauf pour composé)
    Endif
    Gosub AUTORIS_MODIF                                 : # Modification entrées
  Endif
  #----- Si article géré en stock -----#
  If WSTOMGTCOD>1 & [M:PTH1]LINTYP(NOL)<3
    Call STKINIBTN(2,5,3,4,"PTH1","PTR",[M:PTH1]ITMREF(NOL) , [M:PTH0]PRHFCY) From STKENT
  Else
    Raz GBOUT2, GBOUT5, GBOUT3, GBOUT4
  Endif
  # Issue 101375 - 2014-07-10 by CCC : If WRKMOTEUR=1 => Raz GBOUT11
  # Sous-traitance depuis un OF - Service uniquement (?) - FQ 55135 ????
  # If [M:PTH1]VCRTYPORI(NOL)<>10 | [F:ITM]SCSFLG<>2 | find([M:PTH1]WRKMOTEUR(NOL),0,9) | [M:PTH1]CREFLG(NOL)<>0
  If [M:PTH1]VCRTYPORI(NOL)<>10 | find([M:PTH1]WRKMOTEUR(NOL),0,1,9) | [M:PTH1]CREFLG(NOL)<>0
  # accès aux données de l'OF ssi réception sur l'opé sous-traitance
    Raz GBOUT11
  Endif
  # Sous-traitance depuis un EO - GA 22/01/2009 article sous-traité uniquement
  If [M:PTH1]VCRTYPORI(NOL)<>36 | [M:PTH1]LINTYP(NOL)>=3
    Raz GBOUT15
  Endif
  # Accès aux boutons "plan de travail" GBOUT13, GBOUT14
  Gosub INIT_BGP From MTKLIB
  #-----
  If [M:PTH1]SDHNUM(NOL)<>"" & [M:PTH1]VCRNUMORI(NOL)=""
    GBOUT12=mess(129,197,1)-[M:PTH1]SDHNUM(NOL)      : # Livraison xxxxxxxxxx
  Elsif [M:PTH1]VCRNUMORI(NOL)<>"" & [M:PTH1]LINTYP(NOL)<3
    If [M:PTH1]VCRTYPORI(NOL)=36
      GBOUT12=mess(643,197,1)-[M:PTH1]VCRNUMORI(NOL) : # Ordre ss-traitance xxxxxxxx
    Elsif [M:PTH1]VCRTYPORI(NOL)=10
      GBOUT12=mess(1,344,1)-[M:PTH1]VCRNUMORI(NOL)   : # Ordre fabrication xxxxxxxx
    Endif
  Endif
  #----- On les enlève si pas habilité ou en consult
  GBIDC2="M": GFCY=[M:PTH0]PRHFCY : Gosub AUTORIS_OPT From CONTX3
  If !GBIDI2 | GCONSULT=1
    Raz GBOUT3, GBOUT5, GBOUT9
  Endif
  #-----
Else
  Raz GBOUT2, GBOUT3, GBOUT4, GBOUT5, GBOUT11, GBOUT13, GBOUT14, GBOUT15
Endif
# SYMEU 10/12/2008 : branchement traçabilité pièces
If find(GREP,"C","D") or find("CONSPIA",GNAVIG(1..GPILNAV)) Then Raz GBOUT18 Endif
End


$AUTORIS_MODIF
#----Autorisation des modifs de stocks ??
#----Si non efface GBOUT5
#------------------------------------------------------#
# SB nov 99 - Modification d'une entrée en stock       #
#------------------------------------------------------#
Local Shortint NOL : NOL=nolign-1
Local Integer  OK  : OK=1
#----- Lecture article si nécessaire -----#
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif
#----- Lecture ITMFACILITY si nécessaire -----#
If [F:ITF]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
  Read [ITF] ITF0=[M:PTH1]ITMREF(NOL);[M:PTH0]PRHFCY
  If fstat  Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD : Endif
Endif
#----- Si article non géré en stock -----#
If [F:ITF]STOMGTCOD<2 | [M:PTH1]LINTYP(NOL)>2 Raz GBOUT5 : Return : Endif
#----- Si ligne sous-traitance  il faut passer par la suppression-recréation -----#
If [F:ITM]SCSFLG=2  | [M:PTH1]LINTYP(NOL)=2  Raz GBOUT5 : Return : Endif
#----- Est-ce que l'enregistrement est locké par l'objet ? -----#
If GREP="" & [M:PTH0]PTHNUM<>""
  If !GPTH_VERROU     Raz GBOUT5 : Return : Endif
Endif
#----- Pas de modification de stocks si on est en modif -----#
If GREP="M"           Raz GBOUT5 : Return : Endif
Return


$AB1_NBLIG
#------------------------------------------------------#
# Avant exécution du bouton Tunnel commandes, contrats #
#------------------------------------------------------#
Local Shortint NOL : NOL=nolign-1
Local Char     WOBJET(GLONAOB)
Local Char     WCLE1 (GLONVCR)
Local Char     WCLE2 (GLONVCR)
If [M:PTH1]POHTYP(NOL)=2
  WOBJET="POD"
  WCLE1 =num$([M:PTH1]POPLIN(NOL))
  WCLE2 =[M:PTH1]POHNUM(NOL)
Else
  WOBJET="POH"
  WCLE1 =[M:PTH1]POHNUM(NOL)
  WCLE2 =""
Endif
Return

$BB1_NBLIG
#------------------------------------------------------#
# Après exécution du bouton Tunnel commandes, contrats #
#------------------------------------------------------#
nolign=NOL+1 : Gosub RELEC From SUBPTHB
Return


$AB2_NBLIG
#----------------------------------------------------------#
# Avant l'appel à la saisie des entrées (action SAISTOENT) #
#----------------------------------------------------------#
Local Shortint NOL  : NOL=nolign-1
Local Shortint SENS
Call MAJ_CUMULS_LIG(NOL,-1) From SUBPTHD : # Màj cumuls et éléments
Call MAJ_BASTAX_LIG(NOL,-1) From SUBPTHD : # Màj bases et mts taxe
SENS=-1 : Gosub MAJ_TOTWEI               : # Màj totaux poids brut et net
Return

$BB2_NBLIG
#----------------------------------------------------------#
# Après l'appel à la saisie des entrées (action SAISTOENT) #
#----------------------------------------------------------#
If [M:PTH1]LINFLG(NOL)<>1
  Call MAJ_CALTAX_LIG("PTH1",NOL) From TRTACHDIV1
Endif
Call MAJ_BASTAX_LIG(NOL,+1) From SUBPTHD : # Màj bases et mts taxe
Call MAJ_CUMULS_LIG(NOL,+1) From SUBPTHD : # Màj cumuls et éléments
SENS=+1 : Gosub MAJ_TOTWEI  From SUBPTH  : # Màj totaux poids brut et net
[M:PTH1]LINFLG(NOL)=1
Gosub BAPRES_NBLIG From SUBPTH
#----- Si composé affichage des composants -----#
If [M:PTH1]LINTYP(NOL)=2  Affzo [PTH1]10 : Endif
#-----
Return

# Issue X3-38615 - 2017-08-09 by MUARN : modif quantité sst
$AB11_NBLIG
#----------------------------------------------------------#
# Avant l'appel à la saisie des entrées (action SAISTOENT) #
#----------------------------------------------------------#
Local Shortint NOL  : NOL=nolign-1
Local Shortint SENS
Call MAJ_CUMULS_LIG(NOL,-1) From SUBPTHD : # Màj cumuls et éléments
Call MAJ_BASTAX_LIG(NOL,-1) From SUBPTHD : # Màj bases et mts taxe
SENS=-1 : Gosub MAJ_TOTWEI               : # Màj totaux poids brut et net
Return

$BB11_NBLIG
#----------------------------------------------------------#
# Après l'appel à la saisie des entrées (action SAISTOENT) #
#----------------------------------------------------------#
If [M:PTH1]LINFLG(NOL)<>1
  Call MAJ_CALTAX_LIG("PTH1",NOL) From TRTACHDIV1
Endif
Call MAJ_BASTAX_LIG(NOL,+1) From SUBPTHD : # Màj bases et mts taxe
Call MAJ_CUMULS_LIG(NOL,+1) From SUBPTHD : # Màj cumuls et éléments
SENS=+1 : Gosub MAJ_TOTWEI  From SUBPTH  : # Màj totaux poids brut et net
[M:PTH1]LINFLG(NOL)=1
#----- Si composé affichage des composants -----#
If [M:PTH1]LINTYP(NOL)=2  Affzo [PTH1]10 : Endif
#-----
Return
# End issue X3-38615

Subprog B4_NBLIG
#---------------------------------------------------------------------#
# Ouverture du complément lot par clic droit (1er bit de GOUVLOT à 0) #
#---------------------------------------------------------------------#
GOUVLOT = GOUVLOT-mod(GOUVLOT,2)    # Ouverture du complément lot par clic droit (1er bit de GOUVLOT à 0)
GOUVENT = 1     # permet de passer le test de l'ouverture de la fenetre complément lot
End


$AB5_NBLIG
# Issue 121901 - 2017-05-31 by MUARN : déplacé dans SUBPTHD
Gosub AB5_NBLIG From SUBPTHD
Return

$BB5_NBLIG
#---------------------------------------------------#
# Après action SAISTOENTM modif détail entrée stock #
#---------------------------------------------------#
Local Shortint NOL : NOL=nolign-1
If [M:PTH1]POHNUM(NOL)<>""
  SYMBOLE2="POH"+[M:PTH1]POHNUM(NOL) : Unlock=SYMBOLE2
Endif
If GRELITPTH=1
  mkstat = 4
Elsif GPURTRACE=2
 Raz GMESSAGE
 Gosub LECT_EFFAC_TRACE From SUBPTHA
Endif
Return

# Issue 84130 - 2013-03-21 by SR : LANDED COST SDC
$AB6_NBLIG
#---------------------------------------------------#
# Avant Détail structure de coût                    #
#---------------------------------------------------#
#----- Habilitation Détail structure de coût si on trouve L dans chaine boutons autorisés -----#
GOUVSTC = 1
GFCY=[M:PTH0]PRHFCY : GBIDC2="L" : Gosub AUTORIS_OPT From CONTX3
If !GBIDI2
  # vous n'avez pas les droits pour ce site
  GMESSAGE=mess(2,104,1) : GOUVSTC = 0 : Return
Endif
Return

Subprog B9_NBLIG
#----------------#
# Bouton "Solde" #
#----------------#
Local Integer  OK  : OK=1
Local Shortint NOL : NOL=nolign-1
If [M:PTH1]NBLIG=0 | [M:PTH1]ITMREF(NOL)="" End : Endif
#----- L'utilisateur a-t-il droit au solde ? -----#
GFCY=[M:PTH0]PRHFCY
GBIDC2="T" : Gosub AUTORIS_OPT From CONTX3
If !GBIDI2  GMESSAGE=mess(2,104,1)  : GERR=1 : End : Endif
#-- "Solde de la ligne non autorisé."
If [M:PTH1]CREFLG(NOL)=0  GMESSAGE=mess(90,199,1) : GERR=1 : End : Endif
If [M:PTH1]LININVFLG(NOL)<>2
  OK=1 : Call OUINON(mess(249,194,1),OK) From GESECRAN
  If OK=1  End : Endif
Endif
#-------------------------------------------------------------------#
# Vérification si réception est pointée directement par une facture #
#-------------------------------------------------------------------#
If [M:PTH1]LININVFLG(NOL)=2
   Look [PID] PID1(3)=2;[M:PTH0]PTHNUM;[M:PTH1]PTDLIN(NOL)
   [G:PID]currind=1 : [G:PID]currlen=0 : # Réinitialisation clé par défaut
   If !fstat
     #-- "Réception facturée.\Modification ou suppression interdite"
     GERR = 1 : GMESSAGE =mess(112,194,1) : End
  #Elsif [M:PTH1]INVQTYSTU(NOL)>=[M:PTH1]QTYSTU(NOL)
  #  #-- "Réception facturée.\Modification ou suppression interdite"
  #  GERR = 1 : GMESSAGE =mess(112,194,1) : End
   Else
     #-- "Ligne soldée.\Voulez-vous la réactiver ?"
     OK=1 : Call OUINON(mess(43,194,1),OK) From GESECRAN
     If OK=1  End Else [M:PTH1]LININVFLG(NOL)=1 : Endif
   Endif
Else
  [M:PTH1]LININVFLG(NOL)=2
Endif
[M:PTH1]UPDFLG(NOL)=1 : Affzo [PTH1]LININVFLG(NOL) : mkstat=4
GMODIF=9 : # Pour le web
End


$AB12_NBLIG
#------------------------------------------#
# Avant exécution du bouton Tunnel origine #
#------------------------------------------#
Local Shortint NOL       : NOL=nolign-1
Local Char     WOBJET(GLONAOB)
Local Char     WCLE1 (GLONVCR)
Local Char     WCLE2 (GLONVCR)
If [M:PTH1]SDHNUM(NOL)<>"" & [M:PTH1]VCRNUMORI(NOL)=""
  WOBJET="SDH"
  WCLE1 =[M:PTH1]SDHNUM(NOL)
  WCLE2 =""
Elsif [M:PTH1]VCRNUMORI(NOL)<>""
  If [M:PTH1]VCRTYPORI(NOL)=36
    WOBJET="SCO"
    WCLE1=[M:PTH1]VCRNUMORI(NOL)
    WCLE2=""
  Else
    WOBJET="MFG"
    WCLE1=[M:PTH1]VCRNUMORI(NOL)
    WCLE2=""
  Endif
Endif
Return

$BB12_NBLIG
#------------------------------------------#
# Après exécution du bouton Tunnel origine #
#------------------------------------------#
nolign=NOL+1 : Gosub RELEC From SUBPTHB
Return

$AB13_NBLIG
#----------------------------------#
# B13 Plan de production   - GPAO  #
#----------------------------------#
Gosub AB13_BGP From MTKLIB
Return

Subprog AVANT_NBLIG
#-------------#
# Avant nblig #
#-------------#
Local Shortint NOL  : NOL=nolign-1
Local Shortint SENS
Local Decimal  NEWMAXQTY, NEWQTY
# Issue 84130 - 2012-12-11 by SR
Local Integer  WRET
If [M:PTH1]ITMREF(NOL)=""  [M:PTH1]LINFLG(NOL)=0  : Endif
If status<>73
  Call MAJ_CUMULS_LIG(NOL,-1) From SUBPTHD : # Màj cumuls et éléments
  Call MAJ_BASTAX_LIG(NOL,-1) From SUBPTHD : # Màj bases et mts taxe
  SENS=-1 : Gosub MAJ_TOTWEI               : # Màj totaux poids brut et net
Endif
#----- Suppression ligne -----#
If status=65 | status=68 | status=83
  Local Char     SYMBOLE2(30)
  Local Char     NUMCDE(GLONPOH)
  Local Integer  NUMLIN
  Local Integer  NUMSEQ
  Local Shortint WLIG
  Local Char     NUMLIV(GLONSDH)
  # Issue 95496 & 97173 - 2014-02-26 by CCC : delete [F:PWS], [M:ENTW] & [M:SOW]
  #----- Supppression données sous-traitance si ce n'est pas un composant -----#
  If [M:PTH1]LINTYP(NOL)<3 & find([M:PTH1]VCRTYPORI(NOL),10,36)
    Call EFFAC_LIG(NOL, WRET) From SUBPTHC
    If WRET
        mkstat=2
        End
    Endif
  Endif
  If [M:PTH1]CREFLG(NOL)=0
    Call DELSTOENTW(NOL,NOL,"PTH1",1,1,[PTH0]PRHFCY,1,"") From STKENT
  Endif
  # Issue 84130 - 2012-12-11 by SR :Suppression des enregistrements charges
  Call DELSTCDW(NOL,NOL,"PTH1",WRET) From STCLIB
  #----- Déverrou de la livraison (attention si plusieurs lignes) -----#
  If [M:PTH1]SDHNUM(NOL)<>""
    NUMLIV=[M:PTH1]SDHNUM(NOL)
    Raz [M:PTH1]SDHNUM(NOL)
    WLIG=find(NUMLIV,[M:PTH1]SDHNUM(0..[M:PTH1]NBLIG-1))
    If WLIG=0
      SYMBOLE2 = "SDH"+NUMLIV
      Unlock = SYMBOLE2
    Endif
    [M:PTH1]SDHNUM(NOL)=NUMLIV : # Restitution numéro
  Endif
  #--------------------------------------------------#
  # Déverrou de la cde attention si plusieurs lignes #
  #--------------------------------------------------#
  If [M:PTH1]POHNUM(NOL)<>""
    NUMCDE=[M:PTH1]POHNUM(NOL) : # Sauvegarde du numéro de commande
    NUMLIN=[M:PTH1]POPLIN(NOL) : # Sauvegarde du numéro de ligne
    NUMSEQ=[M:PTH1]POQSEQ(NOL) : # Sauvegarde du numéro de séquence
    Raz [M:PTH1]POHNUM(NOL)    : # Effacement à cause du find
    WLIG = find(NUMCDE,[M:PTH1]POHNUM(0..[M:PTH1]NBLIG-1))
    If WLIG = 0
      SYMBOLE2 = "POH"+NUMCDE
      Unlock = SYMBOLE2
    Else
     If NUMCDE<>""
       #----- Lecture ligne commande quantités si nécessaire -----#
       If [F:POQ]POHNUM<>NUMCDE | [F:POQ]POPLIN<>NUMLIN
&        |[F:POQ]POQSEQ<>NUMSEQ
         Read [POQ] POQ0=NUMCDE;NUMLIN;NUMSEQ
         If fstat  Raz [F:POQ] : Endif
       Endif
     Endif
     [M:PTH1]POHNUM(NOL)=NUMCDE : # Restitution numéro de commande pour solde
     #--- Recherche de la nouvelle quantité maxi
     [L]NEWQTY=0
     Raz NEWMAXQTY
     Gosub CAL_MAXQTYRCP  From SUBPTHB
     [M:PTH1]MAXQTYRCP(NOL)=NEWMAXQTY
     #--- Position du solde (J est déclaré et contient l'ancienne valeur)
     Gosub POSITION_SOLDE From SUBPTHB
     If [M:PTH1]WSOLDE(NOL)<>J & !GIMPORT  Affzo [PTH1]WSOLDE(NOL) : Endif
     #--- Réajustement de la quantité maxi sur les autres lignes
     Gosub REAJUST_MAXQTY      From SUBPTHB
     #--- Réajustement du solde sur les autres lignes
     If !GPTH_PICK  Gosub REAJUST_WSOLDE From SUBPTHB : Endif
    Endif
  Endif
  [M:PTH1]POHNUM(NOL)=NUMCDE : # Restitution numéro de commande pour maj_pick
  #----------------------------#
  # Suppression du texte ligne #
  #----------------------------#
  If [M:PTH1]CREFLG(NOL)=0 & left$([M:PTH1]LINTEX(NOL),3)="PTD"
    Call SUP_CLOB([M:PTH1]LINTEX(NOL),GBIDI2) From TRTX3TEX
  Endif
  #----- Pour actualisation liste de gauche -----#
  If !GIMPORT & [M:PTH1]CREFLG(NOL)=0
    Local Shortint WPICK, I
    WPICK=1 : I=nolign-1 : Gosub MARQUAGE_LIGNE From SUBPTHA
  Endif
  [M:PTH1]PCLFLG=1
Elsif status=82 | status=73
   If dim([M:PTH1]ITMREF)=nolign
     GMESSAGE=mess(7,184,1)  #"Tableau des entrées plein."
     GERR = 1
   Else
     Default Mask [PTH1] : Call STKACTLIG(NOL) From STKECR
     Actzo [PTH1]ITMREF(NOL),ITMDES1(NOL)
     If dim([M:PTH1]PCU)>0
        Actzo [PTH1]PCU(NOL),QTYPCU(NOL)
     Elsif dim([M:PTH1]UOM)>0
        Actzo [PTH1]UOM(NOL),QTYUOM(NOL)
     Endif
     If dim([M:PTH1]PCUSTUCOE)>0
        Actzo [PTH1]PCUSTUCOE(NOL)
     Endif
     If dim([M:PTH1]UOMSTUCOE)>0
        Actzo [PTH1]UOMSTUCOE(NOL)
     Endif
     If dim([M:PTH1]MVTDES)>0
        Actzo [PTH1]MVTDES(NOL)
     Endif
   Endif
Elsif status=75
  If [M:PTH1]POHNUM(NOL)<>""
    [L]NEWQTY=[M:PTH1]QTYSTU(NOL)
    Raz NEWMAXQTY
    Gosub CAL_MAXQTYRCP  From SUBPTHB
    [M:PTH1]MAXQTYRCP(NOL)=NEWMAXQTY
  Else
   [M:PTH1]MAXQTYRCP(NOL)=99999999999.999999
  Endif
Endif
If [M:PTH1]SDHNUM(NOL)<>""
  Default Mask [PTH1]
  Call STKDISLIG(NOL) From STKECR
Endif
End

Subprog AS_NBLIG
#-----------------------------------#
# Avant saisie                      #
# Conditions de saisie              #
#-----------------------------------#
Local Shortint NOL : NOL=nolign-1
Local Integer  I
If [M:PTH1]NBLIG>0
  # Issue 90991 - 2013-10-28 by MUARN : SDC au niveau site
  #If sigma(I=0,[M:PTH1]NBLIG-1,([M:PTH1]POHNUM(I)<>"" | [M:PTH1]SDHNUM(I)<>""))
  #  Diszo [PTH0]PRHFCY, BETFCY, BPSNUM
  #Endif
  Diszo [PTH0]PRHFCY, BETFCY, BPSNUM
Elsif [M:PTH1]NBLIG=0 & [M:PTH0]BPSNUM<>""
  Actzo [PTH0]PRHFCY, BETFCY, BPSNUM, CUR
  If [M:PTH0]CUR<>GLOCALDEV  Actzo [PTH0]CHGTYP : Endif
  #----- Réinitialisation tableau des sections entête -----#
  If dim([M:PTH0]NBAXE)>0
    # Issue 74433 - 2011-06-20 by VPO : pb code activité ANA désactivé & GOPTCANA=0
    #Raz [M:PTH0]NBAXE, [M:PTH0]DIE, [M:PTH0]CCE
    Raz [M:PTH0]NBAXE
    If dim([M:PTH0]DIE)>0 : Raz [M:PTH0]DIE : Endif
    If dim([M:PTH0]CCE)>0 : Raz [M:PTH0]CCE : Endif
    Call INIT_CCEH("PTH0","NBAXE","PTH") From TRTX3CPT
  Endif
  #-----
Endif
#- par sécurité, lecture ITM-#
If nolign-1 < 0 End : Endif
If [F:ITM]ITMREF <> [M:PTH1]ITMREF(NOL)
  Read [ITM]ITM0 = [M:PTH1]ITMREF(NOL)
  If fstat : Raz [F:ITM] : Endif
Endif
Call PTH_AS_NBLIG From TWMLIB  # Three way matching GRNA
# Issue 101375 - 2014-08-12 by CCC
If dim(GOLDQTY)>0
    GOLDQTY=0
Endif
End

Subprog C_NBLIG
#----------------------------------------#
# Contrôle sur numéro de ligne réception #
#----------------------------------------#
If [M:PTH1]NBCRELIG>0
  [M:PTH1]NBLIG+=[M:PTH1]NBCRELIG
  If !GIMPORT Affzo [PTH1]1-99 : Endif
  Raz [M:PTH1]NBCRELIG
Endif
# Issue 84557 - 2014-11-03 by SR si au moins une ligne, type de cours non modifiable
If [M:PTH1]NBLIG = 1
    Diszo [M:PTH0]CHGTYP
Elsif [M:PTH1]NBLIG = 0
    If [M:PTH0]CUR<>GLOCALDEV  Actzo [PTH0]CHGTYP : Endif
Endif
# End issue 84557

If GMODIF=9 status=131 : Endif : # Bouton Solde pour le WEB
GMODIF=2
Local Shortint NOL
Local Libelle  WVERIF
Local Integer  I
#-----
If    status=65             : # Annulation simple
      NOL=nolign-1 : Gosub TEST_ANU
Elsif status=68 | status=83 : # Annulation multiple
      For NOL=nolign-1 To nolign1-1
          Gosub TEST_ANU
          If mkstat : Break : Endif
      Next NOL
Endif
If status=75             NOL=nolign-1  : Gosub TEST_MOD    : Endif
If status=73 | status=82 NOL=nolign-1  : Gosub TEST_INSERT : Endif
If find(status,1,4,5,20,21,26,92,93) |
&          (status>128 & status<141)     Gosub TEST_VALID  : Endif
End


Subprog AM_NBLIG
#---------------------------------------------#
# A chaque fois que le nombre de ligne change #
#---------------------------------------------#
#----- Test si modif ligne existante par saisie ou click droit -----#
If status<>75 & status<>131
  [M:PTH1]PCLFLG=9 : # Pour actualisation éventuelle des listes de picking
Endif
#----- Chargement des infos complémentaires venant de la commande si nécessaire -----#
If find(status,65,68,83)
  Gosub TEST_INFOS_COMPL From SUBPTHB
Endif
End

$TEST_INSERT
#---------------------------------#
# Test pour insertion d'une ligne #
#---------------------------------#
If [M:PTH0]BPSNUM=""
  #-- "Le fournisseur n'a pas été renseigné !"
  Call MESSAGE(mess(196,194,1)) From GESECRAN : mkstat=1 : GMODIF=1
Endif
#-----
If [M:PTH1]LINTYP(NOL)>2
  GMESSAGE=mess(97,192,1) : mkstat=1 : GMODIF=1
Endif
# Issue 121901 - 2017-03-31 by MUARN : pas d'insertion si facture ou facture complémentaire sur la réception, et élément facturation réparti
# recherche facture
If [M:PTH1]WINVFLG > 1
  #----- "Ligne réception facturée.\Modification ou suppression impossible" -----#
  # recherche élément facturation réparti
  For I=0 To [M:PTH2]NBFAC-1
    Read [PFI] PFI0=[M:PTH2]INVDTA(I) : If fstat Raz [F:PFI] : Endif
    If 1< [F:PFI]DSPLIN < 7
      GMESSAGE=mess(112,194,1) : mkstat=1 : GMODIF=1
      Break
    Endif
  Next
Else
  Look [PID] PID1(2)=2;[M:PTH0]PTHNUM
  [G:PID]currind=1 : [G:PID]currlen=0 : # Réinitialisation clé par défaut
  If !fstat
    # recherche élément facturation réparti
    For I=0 To [M:PTH2]NBFAC-1
      Read [PFI] PFI0=[M:PTH2]INVDTA(I) : If fstat Raz [F:PFI] : Endif
      If 1< [F:PFI]DSPLIN < 7
        GMESSAGE=mess(112,194,1) : mkstat=1 : GMODIF=1
        Break
      Endif
    Next
  Endif
Endif
# End issue 121901
Return

$TEST_ANU
#----------------------------------#
# Test pour annulation de la ligne #
#----------------------------------#
If dim([M:PTH1]ITMREF)<nolign mkstat=2 : Return : Endif : # Maximum lignes atteint
#----- Suppression ligne d'un composant (service) interdite -----#
If [M:PTH1]LINTYP(NOL)>2
  GMESSAGE=mess(386,194,1) : mkstat=2 : GMODIF=1 : Return
Endif
#-----
If [M:PTH1]CREFLG(NOL)=0 : Return : Endif
#If [M:PTH1]INVQTYSTU(NOL)>0
  #----- Suppression interdite si ligne facturée directement -----#
  Look [PID] PID1(3)=2;[M:PTH0]PTHNUM;[M:PTH1]PTDLIN(NOL)
  [G:PID]currind=1 : [G:PID]currlen=0 : # Réinitialisation clé par défaut
  If !fstat
    #----- "Ligne réception facturée.\Modification ou suppression impossible" -----#
    GMESSAGE=mess(112,194,1) : mkstat=2 : GMODIF=1 : Return
  Endif
  #----- Suppression interdite si ligne facturée totalement
  #If [M:PTH1]INVQTYSTU(NOL)=[M:PTH1]QTYSTU(NOL)
  #  #-- "Ligne réception facturée.\Modification ou suppression impossible"
  #  GMESSAGE=mess(112,194,1) : mkstat=2 : GMODIF=1 : Return
  #Endif
#Endif

# Issue 121901 - 2017-03-31 by MUARN : pas de suppression si autre ligne de réception facturée et élément réparti
If [M:PTH1]WINVFLG > 1
  # recherche élément facturation réparti
  For I=0 To [M:PTH2]NBFAC-1
    Read [PFI] PFI0=[M:PTH2]INVDTA(I) : If fstat Raz [F:PFI] : Endif
    If 1< [F:PFI]DSPLIN < 7
      GMESSAGE=mess(112,194,1) : mkstat=2 : GMODIF=1 : Return
      #Break
    Endif
  Next
Endif
#----- Suppression interdite si un retour a été effectué -----#
If [M:PTH1]RTNQTYPUU(NOL)<>0
  #-- "Ligne réception retournée.\Modification ou suppression impossible"
  GMESSAGE=mess(111,194,1) : mkstat=2 : GMODIF=1 : Return
Endif
#----- Suppression interdite si présence d'un retour non validé -----#
Call VERIF_RETOUR ([M:PTH0]PTHNUM,[M:PTH1]PTDLIN(NOL)) From SUBPTHB
If GMESSAGE<>""  mkstat=2 : GMODIF=1 : Return : Endif
#-----
Raz GERR, GMESSAGE
#-- Controle de période pour article géré
#-- Si site inexistant GERR=1 et GMESSAGE positionné
#-- Si période indéfinie ou traitement interdit à cette date idem
#-- Si période fermée posé la question
Call STKCTRIPT([M:PTH0]RCPDAT,[M:PTH0]PRHFCY,"1") From STKLIB
If GERR=1 : GMESSAGE=mess(21,196,1) : mkstat=2 : GMODIF=1 : Return : Endif
If GERR=2
  I=1 : Call AVERTIR(GMESSAGE,I) From GESECRAN
  If   I=1 Raz GMESSAGE, GERR, mkstat : mkstat=2 : GMODIF=1 : Return
  Else Raz GMESSAGE, GERR, mkstat
  Endif
Endif
#----- Suppression interdite si des qtés ont été allouées -----#
#----- Ou si la quantité n'y est plus
#----- Pour cela il faut que la ligne existe !!!
If [M:PTH1]CREFLG(NOL)<>0
  WVERIF=1 : Gosub VERIF_QTEALL From SUBPTH : # Vérification stock dispo et qtés allouées
  If GMESSAGE<>""  mkstat=1 : GMODIF=1 : Return : Endif
Endif
#-- Suppression interdite si ligne de commande soldée autrement que par réception --#
If [M:PTH1]POHNUM(NOL)<>""
  If [F:POQ]POHNUM<>[M:PTH1]POHNUM(NOL) |
&    [F:POQ]POPLIN<>[M:PTH1]POPLIN(NOL) |
&    [F:POQ]POQSEQ<>[M:PTH1]POQSEQ(NOL)
    Read [POQ] POQ0=[M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat Raz [F:POQ] : Endif
  Endif
  If [F:POQ]LINCLEFLG=2 & [F:POQ]RCPCLEFLG<>2 & [F:POQ]OCNLIN=0
    GMESSAGE=mess(32,194,1) : mkstat=2 : GMODIF= 1: Return
  Endif
Endif
#----- Test si article en inventaire -----#
If [M:PTH1]CREFLG(NOL)<>0
  Read [ITF] ITF0=[M:PTH1]ITMREF(NOL);[M:PTH0]PRHFCY : If fstat  Raz [F:ITF] : Endif
  If [F:ITF]CUNFLG=2
    GMESSAGE=[M:PTH1]ITMREF(NOL)-mess(185,199,1)+"\"+mess(184,193,1) : mkstat=1
  Endif
Endif
# Issue 97484 - 2014-03-17 by SR
# Des charges de cette ligne ont-elles déjà été rapprochées
If [M:PTH1]STCNUM(NOL) <> ""
    Filter [F:STCD]Where VCRTYP = 6 & VCRNUM = [M:PTH0]PTHNUM & VCRLIN = [M:PTH1]PTDLIN(NOL) & STCRFLG=2
    Look [F:STCD]STCD1 First
    Filter [F:STCD]
    If !fstat
        Local Integer OK
        # Des charges rapprochées existent pour ce document. Voulez-vous continuer ?
        OK =2 :Call OUINON (mess(470,194,1),OK) From GESECRAN
        If OK<>2  : mkstat = 2 : GMODIF = 1 : Endif
    Endif
Endif
# End issue 97484
Return

$TEST_MOD
#------------------------------------#
# Test pour modification d'une ligne #
#------------------------------------#
# Issue 113830 - 2016-02-04 by SR : en import, si axes ana importés, on peut arriver ici en création
If GIMPORT & GREP = "C" : Return : Endif

# Issue 101383 GA 08/2014 ne pas afficher en ajout de lignes à une rcp de sous-traitance
#----- Ligne d'un composant, modification interdite ! -----#
If [M:PTH1]LINTYP(NOL)>2 & [M:PTH1]CREFLG(NOL)<>0
  GMESSAGE=mess(387,194,1) : mkstat=2 : GMODIF=1 : Return
Endif
#----- Modification interdite si ligne facturée directement -----#
# Issue 121901 - 2017-03-31 by MUARN : pas de modification si quantité facturée, et élément facturation réparti
If [M:PTH1]INVQTYSTU(NOL) > 0
  #----- "Ligne réception facturée.\Modification ou suppression impossible" -----#
  # recherche élément facturation réparti
  For I=0 To [M:PTH2]NBFAC-1
    Read [PFI] PFI0=[M:PTH2]INVDTA(I) : If fstat Raz [F:PFI] : Endif
    If 1< [F:PFI]DSPLIN < 7
      GMESSAGE=mess(112,194,1) : mkstat=1 : GMODIF=1
      Break
    Endif
  Next
Else
  # Issue 121901 - 2017-05-03 by MUARN : gardé pour FCC/rcp
  #If [M:PTH1]INVQTYSTU(NOL)>0 : # Pas de qté facturée si facture complémentaire !
    Look [PID] PID1(3)=2;[M:PTH0]PTHNUM;[M:PTH1]PTDLIN(NOL)
    [G:PID]currind=1 : [G:PID]currlen=0 : # Réinitialisation clé par défaut
    If !fstat
      GMESSAGE=mess(112,194,1) : mkstat=2 : GMODIF=1 : Return
    Endif
  #Endif
Endif
# End issue 121901
#-- Modification interdite si ligne de commande soldée autrement que par réception --#
If [M:PTH1]POHNUM(NOL)<>""
  If [F:POQ]POHNUM<>[M:PTH1]POHNUM(NOL) |
&    [F:POQ]POPLIN<>[M:PTH1]POPLIN(NOL) |
&    [F:POQ]POQSEQ<>[M:PTH1]POQSEQ(NOL)
    Read [POQ] POQ0=[M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat Raz [F:POQ] : Endif
  Endif
  If [F:POQ]LINCLEFLG=2 & [F:POQ]RCPCLEFLG<>2 & [F:POQ]OCNLIN=0
    GMESSAGE=mess(32,194,1) : mkstat=2 : GMODIF=1 : Return
  Endif
Endif
Return

$TEST_VALID
#-----------------------------------------------#
# Test et traitement à la validation des lignes #
#-----------------------------------------------#
If [M:PTH1]CLCFLG=2
  If GPIHCALTAX=2  | (dim([M:PTH2]DISVATFLG)>0 & find(2,[M:PTH2]DISVATFLG(0..[M:PTH2]NBFAC-1)))
    For GPTH_INDTAX=1 To [M:PTH2]NBTAX
      Gosub CAL_TAXE_GLOB From SUBPTHD
    Next GPTH_INDTAX
  Endif
Endif
If !GIMPORT  Affzo [PTH2]1-99 : Endif
Raz [M:PTH1]CLCFLG
Return

Subprog APRES_NBLIG
#-------------#
# Apres ligne #
#-------------#
# Issue 115661 - 2016-03-31 by SR : Si réception de livraison, on a déjà chargé le mouvement lié à la livraison
If [M:PTH1]SDHNUM(nolign-1)= "" &  (GIMPORT | GWEBSERV)
  Gosub AAPRES_NBLIG : # Si import il faut appeler le début de l'action SAISTOENT !
Else
  Local Shortint NOL : NOL=nolign-1
Endif
Local Shortint SENS
Local Shortint I
Local Integer  WRETOUR
Local Char     NUMCDE(GLONPOH)
Local Integer  NUMLIN
Local Integer  NUMSEQ
# Issue 84130 - 2013-01-13 by SR
Local Integer WRET

#----- Déblocage logique et répartition si abandon de la ligne par escape -----#
#VPO 21/01/11 70944 on pert le status sur MAJ_REPART_LIG et on ne peut plus tester suppression
#If (status=6 | status=7 | status=27 | status=28 | [M:PTH1]ITMREF(NOL)="")
If (status=6 | status=7 | status=27 | status=28 | [M:PTH1]ITMREF(NOL)="") & !(status=65 | status=68 | status=83)
  If [M:PTH1]CREFLG(NOL)=0 & GPTH_SYMBOL2<>""
    Unlock=GPTH_SYMBOL2
  Endif
Endif
Raz GPTH_SYMBOL2
Gosub TRT_BPSNDE : # Traitement de la zone "BL fournisseur"
#----- Si suppression, on répartit les éléments et on se tire -----#
If status=65 | status=68 | status=83
  #----- Suppression des lignes liées au composé (produit fini) -----#
  If NOL<[M:PTH1]NBLIG-1 & [M:PTH1]LINTYP(NOL+1)>2
    I=NOL+1
    While [M:PTH1]LINTYP(I)>2
      nolign=I+1 : Call AVANT_NBLIG From SUBPTH
      Dela I,1,[M:PTH1]NBLIG-1 [M:PTH1]NBLIG : [M:PTH1]NBLIG-=1
    Wend
    Affzo [PTH1]10
    nolign=NOL+1
  Endif
  #-----
  [M:PTH1]LINFLG(NOL)=1
  [M:PTH1]PCLFLG=1 : [M:PTH1]CLCFLG=2 : End
Endif
#----- Actualisation listes gauche -----#
If [M:PTH1]PCLFLG=9 & [M:PTH1]CREFLG(NOL)=0
  If !GIMPORT
    Local Shortint WPICK, I
    WPICK=2 : I=NOL : Gosub MARQUAGE_LIGNE From SUBPTHA
  Endif
Endif
[M:PTH1]PCLFLG=1
#-----
If [M:PTH1]ITMREF(NOL)=""  End : Endif
#-----
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif
# Issue 107177 - 2015-10-21 by MUARN : A faire en APRES_NBLIG et non AM_QTYUOM
If [M:PTH1]LINTYP(NOL)=2 & !GPTH_PICK
  Call CALCUL_COMPOSANTS(NOL) From SUBPTHD
Endif

Call PTH_APRES_NBLIG From TWMLIB   # Three way matching GRNA
#-----
If [M:PTH1]LINFLG(NOL)<>1
  Call MAJ_CALTAX_LIG("PTH1",NOL) From TRTACHDIV1
Endif
Call MAJ_BASTAX_LIG(NOL,+1) From SUBPTHD : # Màj bases et mts taxe
Call MAJ_CUMULS_LIG(NOL,+1) From SUBPTHD : # Màj cumuls et éléments
SENS=+1 : Gosub MAJ_TOTWEI               : # Màj totaux poids brut et net

If !GVTMOD
  # Issue 84130 - 2013-02-06 by MUARN : landed cost
  If [M:PTH1]STCNUM(NOL)<>"" & [M:PTH1]WSTCUPD(NOL)=2
     Gosub ALIM_STCP
     Call GES_STCDW("PTH1",NOL,WRET) From STCCLC
  Endif
Endif
[M:PTH1]LINFLG(NOL)=1

#-----
# FQ 67134 GA 09/2010 pb en saisie de rcp d'article non géré en stock
#If ([M:PTH1]STOMGTCOD(NOL)<2 & [F:ITM]SCSFLG<>2) | [M:PTH1]LINTYP(NOL)>2
# Issue 87754 GA 02/2013 sauf sous-traitance d'OF
#If [M:PTH1]STOMGTCOD(NOL)<2 | [M:PTH1]LINTYP(NOL)>2
If ([M:PTH1]STOMGTCOD(NOL)<2 & [M:PTH1]VCRTYPORI(NOL)<>10) | [M:PTH1]LINTYP(NOL)>2
  [M:PTH1]WSTOFLG(NOL)=2
Endif
If [M:PTH1]CREFLG(NOL)=0 | [M:PTH1]STOMGTCOD(NOL)<2
  #--- Réajustement des qtés max
  Gosub REAJUST_MAXQTY From SUBPTHB
  #--- Positionnement du solde
  If !GPTH_PICK  Gosub REAJUST_WSOLDE From SUBPTHB : Endif
Endif
# Issue 71069 - 2013-08-23 by SR : PJT
# Issue 71069-52 - 2016-08-25 by SR : PJT import
# Si première ligne & pas de code affaire et mono affaire à l'entête on alimente le code affaire à l'entête
If ([M:PTH1]NBLIG <1 | (GPTH_PICK & [M:PTH1]NBLIG=1)| (GIMPORT & [M:PTH1]NBLIG=1)) & [M:PTH0]PJTH = "" & GPJTSNGDOC = 2
   [M:PTH0]PJTH = [M:PTH1]PJT(NOL)
   If !GIMPORT : Affzo [M:PTH0]PJTH : Endif
Endif
#----- Ne rien faire si appel depuis picking (status=0), sera affiché globalement ------#
If !GIMPORT & status<>0
#----- Si composé affichage des composants -----#
  If [M:PTH1]LINTYP(NOL)=2
    Affzo [PTH1]10
  #----- Autrement affichage article, montant ligne et prix de revient -----#
  Else
    Affzo [PTH1]ITMREF(NOL), LINAMT(NOL), CPR(NOL) : # pour remettre la couleur de l'article à jour
  Endif
Endif
#- on remet le nolign, car pb dans appel_moteur_stock -#
nolign = NOL + 1

# Issue 90991 - 2013-11-15 by MUARN : SDC au niveau site
If nolign > 0
  Diszo [PTH0]PRHFCY, BETFCY, BPSNUM
Else
  Actzo [PTH0]PRHFCY, BETFCY, BPSNUM, CUR
Endif
End

#--- Issue 84130 - 2013-01-03 by TS
$ALIM_STCP
Raz [M:STCP]
[M:STCP]VCRTYP  = 6
[M:STCP]VCRNUM  = [M:PTH0]PTHNUM
[M:STCP]VCRLIN  = [M:PTH1]PTDLIN(NOL)
[M:STCP]VCRSEQ  = 0
[M:STCP]STOFCY  = [M:PTH0]PRHFCY
[M:STCP]BPSNUM  = [M:PTH0]BPSNUM
[M:STCP]DAT     = [M:PTH0]RCPDAT
[M:STCP]ICT     = [M:PCEX]EECICT
[M:STCP]CHGTYP  = [M:PTH0]CHGTYP
[M:STCP]NETPRI  = [M:PTH1]NETPRI(NOL)
[M:STCP]QTYPUU  = [M:PTH1]QTYPUU(NOL)
[M:STCP]QTYVOU  = [M:PTH1]QTYVOU(NOL)
[M:STCP]QTYWEU  = [M:PTH1]QTYWEU(NOL)
[M:STCP]PUU     = [M:PTH1]PUU(NOL)
[M:STCP]VOU     = [M:PTH1]LINVOU(NOL)
[M:STCP]WEU     = [M:PTH1]LINWEU(NOL)

# Issue 110325 - 2015-12-01 by SR : Charges sur expéditions
 If [F:POQ]POHNUM <> [M:PTH1]POHNUM(NOL) | [F:POQ]POPLIN <> [M:PTH1]POPLIN(NOL) | [F:POQ]POQSEQ <> [M:PTH1]POQSEQ(NOL)
    Read [F:POQ]POQ0 = [M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat : Raz [F:POQ] : Endif
Endif
If [M:PTH1]POHNUM(NOL)<>""  & [M:PTH1]POHTYP(NOL)<>2
 # Issue 110325 - 2015-12-01 by SR : Charges sur expéditions
   If [M:PTH1]SHIPNUM(NOL) = ""
    [M:STCP]VCRTYPORI  = 14
    [M:STCP]VCRNUMORI  = [M:PTH1]POHNUM(NOL)
    [M:STCP]VCRLINORI  = [M:PTH1]POPLIN(NOL)
    [M:STCP]VCRSEQORI  = [M:PTH1]POQSEQ(NOL)
    [M:STCP]QTYPUUORI  = [F:POQ]QTYPUU
  Else
    #--- Issue 110325 by TS le 09/03/16
    If [F:SHH]SHIPNUM <> [M:PTH1]SHIPNUM(NOL)
       Read [F:SHH]SHH0 = [M:PTH1]SHIPNUM(NOL)
       If fstat : Raz [F:SHH] : Endif
    Endif
    If [F:SHH]SHIPTYP=1
    #--- End issue 110325 by TS le 09/03/16
      If [F:SHD]SHIPNUM <> [M:PTH1]SHIPNUM(NOL) | [F:SHD]SHIPLIN <> [M:PTH1]SHIPLIN(NOL)
        Read [F:SHD]SHD0 = [M:PTH1]SHIPNUM(NOL);[M:PTH1]SHIPLIN(NOL)
        If fstat : Raz [F:SHD] : Endif
      Endif

      [M:STCP]VCRTYPORI  = 38
      [M:STCP]VCRNUMORI  = [F:SHD]SHIPNUM
      [M:STCP]VCRLINORI  = [F:SHD]SHIPLIN
      [M:STCP]VCRSEQORI  = 0
      #If [F:SHD]PRCPFLG = 2
      #  [M:STCP]QTYPUUORI  = [F:SHD]PRCPQTYPUU
      #Else
        [M:STCP]QTYPUUORI  = [F:SHD]SHIQTYPUU
      #Endif
    #--- Issue 110325 by TS le 09/03/16
    Else
      # Si l'expé est une pré-réception de cde, l'origine doit être la commande
      [M:STCP]VCRTYPORI  = 14
      [M:STCP]VCRNUMORI  = [M:PTH1]POHNUM(NOL)
      [M:STCP]VCRLINORI  = [M:PTH1]POPLIN(NOL)
      [M:STCP]VCRSEQORI  = [M:PTH1]POQSEQ(NOL)
      [M:STCP]QTYPUUORI  = [F:POQ]QTYPUU
    Endif
    #--- End issue 110325 by TS le 09/03/16
  Endif
Endif
# End issue 110325
[M:STCP]ORIPPK="PTH"
Return
#---

$AAPRES_NBLIG
#-------------------------------------------------#
# Appelé avant l'action SAISTOENT                 #
# Permet de vérifier s'il faut la lancer ou non   #
#-------------------------------------------------#
Local Shortint WRET
Local Char     LSUP(1)
Local Shortint NOL : NOL=nolign-1
#----- Lecture article si nécessaire -----#
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif
#### FQ 55135 GA 05/2009: pb de maj de l'entrée en stock sur les lignes sous-traitance EO/OF
#### #----- Si article non géré en stock, pas d'appel au SAISTOENT -----#
#### If [M:PTH1]STOMGTCOD(NOL)<2 | [M:PTH1]LINFLG(NOL)>2
####   Raz GOUVENT
####   If [F:ITM]SCSFLG<>2  Return : Endif : # Si non géré et non sous-traitance, c'est fini !
#### Endif
#### #----- Pas de sous-traitance ou sous-traitance sans déclaration de prod -----#
#### If !find([M:PTH1]WRKMOTEUR(NOL),2,3) & [F:ITM]SCSFLG<>2
####   Call OUVENT([M:PTH0]PRHFCY,"PTH1",3,[M:PTH0]TRSCOD,[M:PTH0]BPSNUM,6,
#### &             [M:PTH0]RCPDAT,NOL,[M:PTH1]NBLIG,"PTR",[L]LSUP,[L]WRET) From STKENT
#### Elsif find([M:PTH1]WRKMOTEUR(NOL),2,3) & [M:PTH1]WSTOFLG(NOL)<>2
####   Call CHARG_STT(NOL) From SUBPTHC : # Màj si article sous-traitance avec déclaration
####   Raz GOUVENT
#### Endif
#----- Article Sous-traité ou Service -----# # FQ 55135 & 55088 GA 06/2009
# FQ 67134 GA 09/2010 pb en saisie de rcp sous-traitance d'OF
#If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) & [M:PTH1]WSTOFLG(NOL)<>2
# FQ 72505 GA 03/2011 pb en maj qté de rcp sous-traitance d'EO, recharger si LINTYP=2
#If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) & [M:PTH1]LINTYP(NOL)<2
If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) & [M:PTH1]LINTYP(NOL)<=2
  Call CHARG_STT(NOL) From SUBPTHC : # Màj si article sous-traitance avec déclaration
  # Issue 94522 - 2014-03-06 by CCC : GOUVENT is managed in CHARG_STT. If a window (lot or stock cplt) has to be opened, it will
  #Raz GOUVENT

Elsif [M:PTH1]STOMGTCOD(NOL)>1 & [M:PTH1]LINTYP(NOL)<3
# Article géré en stock (sauf sous-traitance)

  #--- Issue 122854
  If [F:ITM]STOMGTCOD>1 & !find([M:PTH1]UOM(NOL),[F:ITM]STU,[F:ITM]PCU)
    [M:ENTW]WZONPCU = "STU"
    [M:ENTW]WZONQUC = "QTYSTU"
  Else
    [M:ENTW]WZONPCU = "UOM"
    [M:ENTW]WZONQUC = "QTYUOM"
  Endif
  #---

  Call OUVENT([M:PTH0]PRHFCY,"PTH1",3,[M:PTH0]TRSCOD,[M:PTH0]BPSNUM,6,
&             [M:PTH0]RCPDAT,NOL,[M:PTH1]NBLIG,"PTR",[L]LSUP,[L]WRET) From STKENT
Else
  Raz GOUVENT
Endif
Return

$BAPRES_NBLIG
#------------------------------------------#
# Appelé après l'action SAISTOENT          #
# Permet de griser les zones loc et loctyp #
#------------------------------------------#
Local Shortint NOL : NOL=nolign-1
If dim(WCOEFF)<0   Local Decimal  WCOEFF           : Endif
If dim(LUSCAV)<0   Local Char     LUSCAV(2)        : Endif
If dim(LLBEFMT)<0  Local Char     LLBEFMT(GLONARP) : Endif
If dim(LDACCOE)<0  Local Integer  LDACCOE          : Endif
If [M:PTH1]STOMGTCOD(NOL)<2  Return : Endif
If ([F:ITF]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITF]STOFCY<>[M:PTH0]PRHFCY)
  Read [ITF] ITF0=[M:PTH1]ITMREF(NOL);[M:PTH0]PRHFCY
  If fstat : Raz [F:ITF] : Endif
Endif
If [F:ITF]LOCMGTCOD<>2 : Return : Endif
#-- Si pas d'emplacement  on dégage
If dim([M:PTH1]LOT)<=0 : Return : Endif
#-- Si sortie ok avec gestion des emplacements
If [M:PTH1]WSTOFLG(NOL)<>0 & [M:PTH1]LOC(NOL)<>"" & [M:PTH1]LOC(NOL)<>"$"
  If [M:PTH1]LOCTYP(NOL)<>""
    Read [TLO]TLO0=[M:PTH0]PRHFCY;[M:PTH1]LOCTYP(NOL)
    If fstat : Raz [F:TLO] : Endif   # Ne doit jamais arriver
    #-- Si gestion du remlissage
    If [F:TLO]FILMGTFLG=2
      # Vérifie que l'unité correspond à une unité de stock ou de conditionnement
      Call CTLUOM([M:PTH1]ITMREF(NOL),1,[M:PTH0]BPSNUM, [M:PTH1]UOM(NOL), [L]WCOEFF,
&                 [L]LUSCAV, [L]LLBEFMT, [L]LDACCOE) From STKACT
      #--- Issue 109857
      Actzo [PTH1]LOCTYP(NOL), LOC(NOL)
      Affzo [PTH1]LOCTYP(NOL), LOC(NOL)
      #---
      # Si unité spécifique au fournisseur
      If find("AF", [L]LUSCAV)
        [M:PTH1]WSTOSAI(NOL)=left$([M:PTH1]WSTOSAI(NOL),4)+"22"+right$([M:PTH1]WSTOSAI(NOL),7)
        Diszo [PTH1]LOCTYP(NOL), LOC(NOL)
        Affzo [PTH1]LOCTYP(NOL), LOC(NOL)
      Endif
      # Si l'unité du document ne fait pas partie des unités autorisées en remplissage
      If !sigma(I=0,8,[F:TLO]PCU(I)=[M:PTH1]UOM(NOL))
        [M:PTH1]WSTOSAI(NOL)=left$([M:PTH1]WSTOSAI(NOL),4)+"22"+right$([M:PTH1]WSTOSAI(NOL),7)
        Diszo [PTH1]LOCTYP(NOL), LOC(NOL)
        Affzo [PTH1]LOCTYP(NOL), LOC(NOL)
      Endif
    Endif
  Endif
Endif
Return

Subprog IB_POHNUM
#------------------------#
# Init bouton numéro cde #
#------------------------#
Raz GBOUT1
GBOUT1 = mess(48,198,1)
End

Subprog AS_POHNUM(VALEUR)
#-------------------------#
# Avant saisie numéro cde #
#-------------------------#
Variable Char     VALEUR
Local Shortint NOL : NOL=nolign-1
#---------------------------------------------------------------#
# on ne peut pas modifier le numéro cde si ligne est deja créée #
# creflg = 0 si nouvelle ligne                                  #
#---------------------------------------------------------------#
If VALEUR<>"" | [M:PTH1]WSTOFLG(NOL)<>0 | [M:PTH1]SDHNUM(NOL)<>""
  mkstat = 2
Endif
End

Subprog C_POHNUM(VALEUR)
#-----------------------------#
# Contrôle numéro de commande #
#-----------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If [M:PTH1]CREFLG(NOL)<>0 : End : Endif
If GPTHDIR<>2 & VALEUR=""
  GERR=1 : GMESSAGE=mess(247,194,1)
  mkstat=2
  End
Endif
End

$AB1_POHNUM
#------------------------------------------------------#
# Avant exécution du bouton Tunnel commandes, contrats #
#------------------------------------------------------#
Local Char     WOBJET(GLONAOB)
Local Char     WCLE1 (GLONVCR)
Local Char     WCLE2 (GLONVCR)
If [F:POH]POHNUM<>VALEUR
  Read [POH] POH0=VALEUR : If fstat  Raz [F:POH] : Endif
Endif
If [F:POH]POHTYP=2
  WOBJET="POD"
  WCLE1 = "1"
  WCLE2 =VALEUR
Else
  WOBJET="POH"
  WCLE1=VALEUR
  WCLE2=""
Endif
Return

$BB1_POHNUM
#------------------------------------------------------#
# Apres exécution du bouton Tunnel commandes, contrats #
#------------------------------------------------------#
If WOBJET="POD"
  VALEUR=[F:POC]POHNUM
Else
  VALEUR=[F:POH]POHNUM
Endif
Return

Subprog AM_POHNUM(VALEUR)
#------------------------#
# Après modif numéro cde #
#------------------------#
Variable Char     VALEUR
Local Shortint NOL : NOL=nolign-1
#-----------------------#
# verif   si cde signée #
#-----------------------#
Read [POH]POH0 = VALEUR
If fstat = 0
  If [F:POH]BPSNUM <> [M:PTH0]BPSNUM
    GMESSAGE  = mess(105,194,1)
    mkstat = 2
  Elsif [F:POH]APPFLG <= 2
    GMESSAGE  = mess(101,194,1)
    mkstat    = 2
  Elsif [F:POH]RCPFLG >3 & GRCPORD = 1
    GMESSAGE  = mess(101,194,1)
    mkstat    = 2
  Else
    #---------------------------#
    # verification meme societe #
    #---------------------------#
    Read [FCY] FCY0 = [F:POH]POHFCY
    If fstat  :  Raz [F:FCY] : Endif
    If [F:FCY]LEGCPY <> GSOCIETE
      GMESSAGE = mess(2,194,1)
      mkstat = 2
    Endif
  Endif
Else GMESSAGE  = mess(178,199,1)
     mkstat = 2
Endif
If mkstat <> 0
  GERR = 1
Else
  [M:PTH1]POHTYP (NOL) = [F:POH]POHTYP
  [M:PTH1]POHFCY (NOL) = [F:POH]POHFCY
Endif
End

Subprog AS_POPLIN(VALEUR)
#--------------------------#
# Apres modif numéro ligne #
#--------------------------#
Variable Decimal VALEUR
Local Shortint NOL : NOL=nolign-1
Raz [F:POQ]
If [M:PTH1]POHNUM(NOL)=""
   # Issue 115504 - 2016-03-24 by SR : Razer les buffers
   Raz [F:POH], [F:POQ], [F:POP]
  mkstat=2
Elsif VALEUR<>0 | [M:PTH1]WSTOFLG(NOL)<>0 | [M:PTH1]SDHNUM(NOL)<>""
  mkstat=2
Endif
End

# Issue 106506 - 2015-04-23 by SR : Landed Cost
Subprog C_POPLIN(VALEUR)
#--------------------------#
# Contrôle numéro ligne    #
#--------------------------#
Variable Decimal VALEUR
Local Integer I,J
Local Char WMSG(250) # Issue 71069 - 2016-04-01 by SR : PJT
Local Integer NOL : NOL = nolign-1
Read [F:POQ]POQ0 = [M:PTH1]POHNUM(NOL);VALEUR;1
If !fstat
  # Si commande gérée en expédition
  If [F:POQ]SHIQTYSTU <> 0
    # Si pas import ni Web service , picking obligatoire
    If !GIMPORT & !GWEBSERV
        GMESSAGE = mess(506,194,1) : mkstat=1 : End
    # Si import ou Web service
    Else
      # Issue 108538 - 2015-06-05 by SR : Landed Cost
      # en import , obligation d'importer le numéro d'expédition
      If [M:PTH1]SHIPNUM(NOL) = ""
         # Ligne de commande expédiée et numéro d'expédition non renseigné
         GMESSAGE = mess(523,194,1) : mkstat=1 : End
      Endif
      # End issue 108538
      # contrôle d'unicité de la ligne de commande
      J=0
      J = sigma(I=0,[M:PTH1]NBLIG-1,[M:PTH1]POHNUM(I)=[F:POQ]POHNUM & [M:PTH1]POPLIN(I) = [F:POQ]POPLIN &
&               [M:PTH1]POPLIN(I) = [F:POQ]POPLIN & I <> NOL)
      If J
        GMESSAGE = mess(499,194,1) - num$(J)
        mkstat = 1
        End
      Endif
    Endif
  # Sinon
  Else
     # contrôle que la ligne de commande n'est pas dans un container non expédié
     Filter [F:CTRD] Where POHNUM = [F:POQ]POHNUM & POPLIN = [F:POQ]POPLIN & POQSEQ = [F:POQ]POQSEQ
     Look [F:CTRD] First With Nohint
     Filter [F:CTRD]
     If !fstat
       GMESSAGE = mess(524,194,1)
       mkstat = 1
       End
     Endif
  Endif
  # Issue 71069 - 2016-04-01 by SR : PJT
  # tests backporting : Contrôler aussi la première ligne si PJTH renseigné
  If [M:PTH1]NBLIG >0 | [M:PTH0]PJTH <> ""
    If [F:POH]POHTYP = 1
     Read [F:POP] POP0 = [M:PTH1]POHNUM(NOL);VALEUR;1
     If fstat : Raz [F:POP] : Endif
     If func TRTPJT.IS_PJT_AVAILABLE([F:POP]PJT, "[M:PTH1]PJT", WMSG) = G_NON Then
       GMESSAGE = WMSG
       mkstat = 1
       End
     Endif
    Else
       Read [POC] POC0=[M:PTH1]POHNUM(NOL);VALEUR
       If fstat  Raz [F:POC] : Endif
       If func TRTPJT.IS_PJT_AVAILABLE([F:POC]PJT, "[M:PTH1]PJT", WMSG) = G_NON Then
         GMESSAGE = WMSG
         mkstat = 1
         End
      Endif
    Endif
  Endif
  # End issue 71069
Endif
End
# End issue 106506

Subprog AM_POPLIN(VALEUR)
#--------------------------#
# Apres modif numéro ligne #
#--------------------------#
Variable Decimal VALEUR
Local Integer  NOL : NOL=nolign-1
Local Shortint WRET
#-------------------------------#
# lecture commande si différent #
#-------------------------------#
If [F:POH]POHNUM<>[M:PTH1]POHNUM(NOL)
  Read [POH] POH0=[M:PTH1]POHNUM(NOL) : If fstat  Raz [F:POH] : Endif
Endif
#-------------------------#
# lecture détail commande #
#-------------------------#
If [F:POH]POHTYP<>2
  [M:PTH1]POQSEQ(NOL) = 1
  Read [POQ] POQ0 = [M:PTH1]POHNUM(NOL);VALEUR;[M:PTH1]POQSEQ(NOL)
  If fstat
    Raz [F:POQ]
    GMESSAGE = mess(23,100,1)
    GMESSAGE+=" "+[M:PTH1]POHNUM(NOL)+"/"+num$(VALEUR)+"/"+num$([M:PTH1]POQSEQ(NOL))
    mkstat=2 : End
  Endif
  #----- Ligne composant interdite, saisissez le composé ! -----#
  If [F:POQ]LINTYP>2
    GMESSAGE=mess(385,194,1) : mkstat=1 : End
  Endif
  #----- Lecture ITMMASTER si nécessaire -----#
  If [F:ITM]ITMREF<>[F:POQ]ITMREF
    Read [ITM] ITM0=[F:POQ]ITMREF : If fstat  Raz [F:ITM] : Endif
  Endif
  #----- Lecture ITMFACILITY si nécessaire -----#
  If [F:ITF]ITMREF<>[F:POQ]ITMREF | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
    Read [ITF] ITF0=[F:POQ]ITMREF;[M:PTH0]PRHFCY
    If fstat  Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD : Endif
  Endif
  #----- Contrôle période comptable si article non géré en stock -----#
  If [F:ITF]STOMGTCOD<2
    Call CTLPER([M:PTH0]PRHFCY,[M:PTH0]RCPDAT) From TRTACHCTL1
    If mkstat  End : Endif
  Endif
  #-----
  [M:PTH1]POPLIN(NOL) = VALEUR
  nolign=NOL+1
  Gosub DIVPTHLIG From SUBPTHB
  If mkstat  Raz [M:PTH1]POPLIN(NOL) : Endif
Endif
#--- Dans le cas d'une réception sur contrat la sélection de la ligne
#--- de contrat est exécutée en après-modif
#--- En import on n'exécute pas l'action sélection de ligne
#--- qui est cochée à import=non
If (GIMPORT | GWEBSERV) & [F:POH]POHTYP = 2
  #-- Si le numéro de séquence est renseigné on tente de faire l'import sur ce numéro
  If [F:PTD]POQSEQ <> 0
    [M:PTH1]POQSEQ(NOL) = [F:PTD]POQSEQ
    Read [POQ] POQ0 = [M:PTH1]POHNUM(NOL);VALEUR;[F:PTD]POQSEQ
    If fstat Raz [F:POQ]
       GMESSAGE = mess (23,100,1)
       GMESSAGE+=" "+[M:PTH1]POHNUM(NOL)+"/"+num$(VALEUR)+"/"+num$([F:PTD]POQSEQ(NOL))
       mkstat =  2 : End
    Endif
  Else
  #-- Sinon on recherche le premier
    Filter [POQ] Where POHNUM=[M:PTH1]POHNUM(NOL) & POPLIN=VALEUR &
&                      PRHFCY=[M:PTH0]PRHFCY & ORI <> 2 & WIPSTA <2 & LINCLEFLG < 2
    Read [POQ]POQ0 First : # La clé POQ0 est meilleure que POQ2
    Filter [POQ]
    If fstat Raz [F:POQ] :
       GMESSAGE = mess (23,100,1)
       GMESSAGE+=" "+[M:PTH1]POHNUM(NOL)+"/"+num$(VALEUR)+"/??????"
       mkstat =  2 : End : Endif
  Endif
  #----- Lecture ITMMASTER si nécessaire -----#
  If [F:ITM]ITMREF<>[F:POQ]ITMREF
    Read [ITM]ITM0=[F:POQ]ITMREF : If fstat  Raz [F:ITM] : Endif
  Endif
  #----- Lecture ITMFACILITY si nécessaire -----#
  If [F:ITF]ITMREF<>[F:POQ]ITMREF | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
    Read [ITF] ITF0=[F:POQ]ITMREF;[M:PTH0]PRHFCY
    If fstat  Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD : Endif
  Endif
  #----- Contrôle période comptable si article non géré en stock -----#
  If [F:ITF]STOMGTCOD<2
    Call CTLPER([M:PTH0]PRHFCY,[M:PTH0]RCPDAT) From TRTACHCTL1
    If mkstat  End : Endif
  Endif
  #-----
  [M:PTH1]POPLIN(NOL)=VALEUR
  [M:PTH1]POQSEQ(NOL)=[F:POQ]POQSEQ
  [M:PTH1]ITMREF(NOL)=[F:POQ]ITMREF
  nolign=NOL+1
  Gosub DIVPTHLIG From SUBPTHB
  If mkstat
    Raz [M:PTH1]POPLIN(NOL), [M:PTH1]POQSEQ(NOL), [M:PTH1]ITMREF(NOL)
  Endif
Endif
End

Subprog IB_ITMREF
#--------------------#
# Init bouton itmref #
#--------------------#
Local Shortint NOL : NOL=nolign-1
Raz GBOUT1, GBOUT2
GBOUT1 =mess(22,198,1)   : # Articles
GBOUT2 =mess (4,198,1)   : # Article-sites
If [M:PTH1]POHNUM(NOL) =""
  Raz GBOUT3
Endif
End

Subprog AV_ITMREF(VALEUR)
#---------------------------------------------------------------------#
# Avant zone                                                          #
# Affichage référence article en rouge si attente de saisie détaillée #
#---------------------------------------------------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If [M:PTH1]WSTOFLG(NOL)=0 & [M:PTH1]CREFLG(NOL)=0
  pcolor=GCOUL(1) : # Rouge
Else
  pcolor=GCOUL(0) : # Noir
Endif
End

Subprog AS_ITMREF(VALEUR)
#--------------------------#
# Avant saisie ref article #
#--------------------------#
Variable Char    VALEUR()
Local    Shortint NOL     : NOL=nolign-1
If [M:PTH1]POPLIN(NOL)<>0 | [M:PTH1]WSTOFLG(NOL)<>0 | [M:PTH1]SDHNUM(NOL)<>""
  mkstat = 2
Endif
#-- Réception directe uniquement
If [M:PTH1]POHNUM(NOL)=""
  Raz [F:POQ]
Endif
End

Subprog AM_ITMREF(VALEUR)
#--------------------#
# Après-modif itmref #
#--------------------#
Variable Char  VALEUR
Local Shortint NOL : NOL=nolign-1
Local    Decimal  WCPRAMT # Issue 70985 - 2012-04-03 by MUARN : landed cost
Local    Integer  WSTAT   # Issue 70985 - 2012-04-03 by MUARN : landed cost
#----- Contrôle si réception directe permise -----#
If varmode([M:PTH1]POHNUM,NOL)<>0 & GPTHDIR<>2
  Call ERREUR(mess(247,194,1)) From GESECRAN : mkstat=1 : End
Endif
#----- Contrôle si article actif ? -----#
If [F:ITM]ITMSTA=3
  Local Integer WRET : WRET=2
  Call AVERTIR(mess(3,196,1)-"("+mess([F:ITM]ITMSTA,246,1)+")",WRET) From GESECRAN
  If WRET=1  mkstat=1 : End : Endif
Elsif [F:ITM]ITMSTA<>1
  Call ERREUR(mess(3,196,1)-"("+mess([F:ITM]ITMSTA,246,1)+")") From GESECRAN
  mkstat=1 : End
Endif
#-----
Gosub VERIF_ITM From SUBPTHB : If mkstat  End : Endif
#----- Lecture ITMFACILITY si nécessaire -----#
If [F:ITF]ITMREF<>VALEUR | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
  Read [ITF] ITF0=VALEUR;[M:PTH0]PRHFCY
  If fstat
    Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD
    #----- Si article géré en stock, l'article-site doit exister ! -----#
    If [F:ITM]STOMGTCOD>1
      GMESSAGE=VALEUR-mess(25,192,1)-[M:PTH0]PRHFCY : mkstat=1 : End
    Endif
  Endif
Endif
#----- Contrôle période comptable si article non géré en stock -----#
If [F:ITF]STOMGTCOD<2
  Call CTLPER([M:PTH0]PRHFCY,[M:PTH0]RCPDAT) From TRTACHCTL1
  If mkstat  End : Endif
Endif

# Issue 94755 GA 12/2013 pas de message si composant fourni par le sous-traitant
#--- Contrôle date entrée par rapport aux dates mouvements en attente
If [F:ITF]STOMGTCOD>1 & [M:PTH1]LINTYP(NOL)<3
  Local Date    LDATRUP
  Local Decimal LQTYRUP
  #--- Bug 69674
  #Call CTLRUP([M]PRHFCY,VALEUR,[M]RCPDAT,1,LDATRUP,LQTYRUP) From STKLIB
  Call CTLRUP([M:PTH0]PRHFCY,VALEUR,[M:PTH0]RCPDAT,1,LDATRUP,LQTYRUP) From STKLIB
  #---
Endif
#---

#----- Si import et no cde renseigné, recherche de la ligne de commande -----#
If (GIMPORT | GWEBSERV) & [M:PTH1]POHNUM(NOL)<>""
  #------ Commande ouverte et no de séquence renseigné -----#
  If [F:POH]POHTYP=2 & [F:PTD]POQSEQ<>0
    [M:PTH1]POQSEQ(NOL)=[F:PTD]POQSEQ
    #----- No ligne renseigné -----#
    If [M:PTH1]POPLIN(NOL)<>0
      Filter [POQ] Where POHNUM=[M:PTH1]POHNUM(NOL)
&                      & POPLIN=[M:PTH1]POPLIN(NOL)
&                      & POQSEQ=[M:PTH1]POQSEQ(NOL)
&                      & ITMREF=VALEUR
&                      & PRHFCY=[M:PTH0]PRHFCY & ORI<>2 & WIPSTA<2 & LINCLEFLG<2
    #----- No ligne non renseigné -----#
    Else
      Filter [POQ] Where POHNUM=[M:PTH1]POHNUM(NOL)
&                      & POQSEQ=[M:PTH1]POQSEQ(NOL)
&                      & ITMREF=VALEUR
&                      & PRHFCY=[M:PTH0]PRHFCY & ORI<>2 & WIPSTA<2 & LINCLEFLG<2

    Endif
  #-----
  Else
    #----- No ligne renseigné -----#
    If [M:PTH1]POPLIN(NOL)<>0
      Filter [POQ] Where POHNUM=[M:PTH1]POHNUM(NOL)
&                      & POPLIN=[M:PTH1]POPLIN(NOL)
&                      & ITMREF=VALEUR
&                      & PRHFCY=[M:PTH0]PRHFCY & ORI<>2 & WIPSTA<2 & LINCLEFLG<2
    #----- No ligne non renseigné -----#
    Else
      Filter [POQ] Where POHNUM=[M:PTH1]POHNUM(NOL)
&                      & ITMREF=VALEUR
&                      & PRHFCY=[M:PTH0]PRHFCY & ORI<>2 & WIPSTA<2 & LINCLEFLG<2
    Endif
  Endif
  #-----
  Read [POQ] POQ0 First : # La clé POQ0 est meilleure que POQ2
  Filter [POQ]
  If fstat
    #----- XXXXXXXXXX Ligne commande introuvable ! -----#
    Raz [F:POQ] : GMESSAGE=[M:PTH1]POHNUM(NOL)-VALEUR-mess(360,197,1) : mkstat=1 : End
  Endif
  #-----
  [M:PTH1]POPLIN(NOL)=[F:POQ]POPLIN
  [M:PTH1]POQSEQ(NOL)=[F:POQ]POQSEQ
  [M:PTH1]ITMREF(NOL)=[F:POQ]ITMREF
Endif
#----- Relecture BPARTNER si nécessaire -----#
If [F:BPR]BPRNUM<>[M:PTH0]BPSNUM
  Read [BPR] BPR0=[M:PTH0]BPSNUM : If fstat  Raz [F:BPR] : [F:BPR]LAN=GLANGUE : Endif
Endif
#-----
If [M:PTH1]ITMDES(NOL)="" | [M:PTH1]POHNUM(NOL)=""
  #----- Chargement des désignations article -----#
  #Call CHARGE_ITMDES("DES1AXX",[F:BPR]LAN,[F:ITM]ITMREF,[M:PTH1]ITMDES(NOL)) From TRTX3
  #If [M:PTH1]ITMDES(NOL)="" [M:PTH1]ITMDES(NOL)=[F:ITM]ITMDES1 : Endif
  Call CHARGE_DEFITMDES("DES1AXX",[F:BPR]LAN,[F:ITM]ITMREF,[M:PTH1]ITMDES(NOL), "[F:ITM]") From TRTX3   # FGR 29/06/2009 : X3SUIVI56129
  #[M:PTH1]ITMDES1(NOL)=[F:ITM]ITMDES1
  Call CHARGE_DEFITMDES("DES1AXX",GLANGUE,[F:ITM]ITMREF,[M:PTH1]ITMDES1(NOL), "[F:ITM]") From TRTX3   # FGR 29/06/2009 : X3SUIVI56129
Endif
If [M:PTH1]ORICRY(NOL)=""
  [M:PTH1]ORICRY (NOL) = [F:BPR]CRY
Endif
#- Affectation de la classe M (bien qu'on soit en apres_modif du champ) -#
#- pour afficher l'article en rouge si besoin est (et pas à blanc)      -#
[M:PTH1]ITMREF (NOL) = VALEUR
nolign=NOL+1
If [M:PTH1]POHNUM(NOL)=""
  Gosub CHARG_RCP_DIR : If mkstat  End : Endif
Endif
Affzo [PTH1]ITMDES(NOL), ITMDES1(NOL), UOM(NOL),    QTYUOM(NOL), WSOLDE(NOL), PUU(NOL),
&           QUAFLG(NOL), WSOLDE(NOL),  NETCUR(NOL), CPRCOE(NOL), CPRAMT(NOL), CPRCUR(NOL), STCNUM(NOL)
If GACTDEB=2  Affzo [PTH1]EECINCRAT(NOL) : Endif
Affzo [PTH1]ORICRY(NOL)

# Issue 84130 - 2012-12-12 by MUARN : landed cost - poids et volume
[M:PTH1]LINWEU(NOL)=[M:PTH2]DSPWEU
[M:PTH1]LINVOU(NOL)=[M:PTH2]DSPVOU
If !GIMPORT Affzo [PTH1]LINWEU(NOL),LINVOU(NOL) : Endif

nolign=NOL+1
End

$CHARG_RCP_DIR
#------------------------------------#
# Chargement d'une réception directe #
# NOL est déclaré et renseigné       #
#------------------------------------#
If GMODU(5)=2  Raz [F:SDD] : Endif : # à cause de l'INISEC "PTD"
#-- Initialisation des zones de stock à ne faire qu'en réception directe !!!
Default Mask [PTH1]
Call INIZONENT([F:ITM]ITMREF,"PTH1",[M:PTH0]PRHFCY,[M:PTH0]BPSNUM,1,"",
& NOL,3,[M:PTH0]TRSCOD,[M:PTH0]PTHNUM,3,1) From STKECR
If mkstat : Return : Endif
#----- Lecture ITMFACILITY si nécessaire -----#
If [F:ITF]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITF]STOFCY<>[M:PTH0]PRHFCY
  Read [ITF] ITF0=[M:PTH1]ITMREF(NOL);[M:PTH0]PRHFCY
  If fstat  Raz [F:ITF] : [F:ITF]STOMGTCOD=[F:ITM]STOMGTCOD : Endif
Endif
#-----
[M:PTH1]STOMGTCOD(NOL)=[F:ITF]STOMGTCOD
[M:PTH1]LINCAT(NOL)=1
#----- Site de commande par défaut -----#
Raz [M:PTH1]POHFCY(NOL)
#----- (1) Site de réception si celui-ci est site d'achat -----#
Read [FCY] FCY0=[M:PTH0]PRHFCY : If fstat  Raz [F:FCY] : Endif
If [F:FCY]PURFLG=2
  [M:PTH1]POHFCY(NOL)=[M:PTH0]PRHFCY
#----- (2) Site d'achat de l'utilisateur si appartient à la même société -----#
Elsif GFCYDEF(6)<>""
  Read [FCY] FCY0=GFCYDEF(6) : If fstat  Raz [F:FCY] : Endif
  If [F:FCY]LEGCPY=GSOCIETE & [F:FCY]PURFLG=2
    [M:PTH1]POHFCY(NOL)=GFCYDEF(6)
  Endif
Endif
#----- (3) 1er site d'achat appartenant à la même société -----#
If [M:PTH1]POHFCY(NOL)=""
  Filter [FCY] Where LEGCPY=GSOCIETE & PURFLG=2
  Read [FCY] FCY1 First
  Filter [FCY]
  If fstat
    Raz [F:FCY]
  Else
    [M:PTH1]POHFCY(NOL)=[F:FCY]FCY
  Endif
Endif
#-- Seront rajoutés en controle de création de l'ITP
#-- Les controle des coefficients modifiable ou non.
#-- Ainsi si non modifiable au niveau de l'article, le coeff
#-- Ne sera pas modifiable au niveau du fournisseur
If [F:ITP]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITP]BPSNUM<>[M:PTH0]BPSNUM
  Read [ITP] ITP0=[M:PTH1]ITMREF(NOL);[M:PTH0]BPSNUM
  If fstat  Raz [F:ITP] : Endif
Endif
If [F:ITP]ITMREF=VALEUR & [F:ITP]BPSNUM=[M:PTH0]BPSNUM
  If GACTDEB=2  [M:PTH1]EECINCRAT(NOL)=[F:ITP]EECINCRAT : Endif
  [M:PTH1]PUU(NOL)        = [F:ITP]PUU
  [M:PTH1]UOM(NOL)        = [F:ITP]PUU
  [M:PTH1]UOMPUUCOE (NOL) = 1
  [M:PTH1]UOMSTUCOE(NOL)  = [F:ITP]PUUSTUCOE
  [M:PTH1]UOMPUUCOE(NOL)  = 1
Else
  [M:PTH1]PUU (NOL)       = [F:ITM]PUU
  [M:PTH1]UOM (NOL)       = [F:ITM]PUU
  [M:PTH1]UOMPUUCOE (NOL) = 1
  [M:PTH1]UOMSTUCOE(NOL)  = [F:ITM]PUUSTUCOE
Endif

#--- Issue 92026 by TS
If dim([L]WCOEFF)<0     Local Decimal  WCOEFF           : Endif
If dim([L]LUSCAV)<0     Local Char     LUSCAV(2)        : Endif
If dim([L]LLBEFMT)<0    Local Char     LLBEFMT(GLONARP) : Endif
If dim([L]LDACCOE)<0    Local Integer  LDACCOE          : Endif
Gosub CONT_UNI_RCP From SUBPTHB
#---

If GACTDEB=2
  If [M:PTH1]EECINCRAT(NOL) = 0
     #----- Relecture BPSUPPLIER si nécessaire -----#
     If [F:BPS]BPSNUM<>[M:PTH0]BPSNUM
       Read [BPS] BPS0=[M:PTH0]BPSNUM : If fstat Raz [F:BPS] : Endif
     Endif
     #-----
    [M:PTH1]EECINCRAT (NOL) = [F:BPS]EECINCRAT
  Endif
Endif
If [M:PTH1]POHTYP(NOL)=2 & [M:PTH0]BETFCY=2
  [M:PTH1]WSOLDE(NOL)=2
Else
  [M:PTH1]WSOLDE(NOL)=1
Endif
#----- Alimentation de la province de sortie et du pays expéditeur -----#
If [F:BPS]BPSNUM<>[M:PTH0]BPSNUM
  Read [BPS] BPS0=[M:PTH0]BPSNUM : If fstat  Raz [F:BPS] : Endif
Endif
#----- Lecture de l'adresse d'expédition si nécessaire -----#
If [F:BPA]BPATYP<>1 | [F:BPA]BPANUM<>[M:PTH0]BPSNUM | [F:BPA]BPAADD<>[F:BPS]BPAADD
  Read [BPA] BPA0=1;[M:PTH0]BPSNUM;[F:BPS]BPAADD
  If fstat  Raz [F:BPA] : Endif
Endif
#-----
If dim([M:PTH1]SATISS)>0  [M:PTH1]SATISS(NOL)=[F:BPA]SAT : Endif
[M:PTH1]BPOCRY(NOL)=[F:BPA]CRY
#-----

#----- Initialisation des landed cost -----#
# Issue 94186 - 2013-11-06 by MUARN : landed cost et sous traitance
# Issue 95686 - 2014-01-08 by MUARN : landed cost désactivés en sous traitance
If [M:PTH1]LINTYP(NOL)<2
  # Issue 70985 - 2012-02-17 by MUARN : alimentation coefficient frais d'approche et coût achat forfaitaire
  # Issue 70985 - sr 04.12. Recalculer le cout unitaire en devise societe
  Call RECH_COST([M:PTH0]PRHFCY,[M:PTH0]BPSNUM, [M:PTH1]ITMREF(NOL), [M:PTH1]CPRCOE(NOL), WCPRAMT, [M:PTH1]STCNUM(NOL)) From STCLIB
  If GLOCALDEV <> GSYSCUR
      Call CONVERT2(GSYSCUR,GLOCALDEV, GLOCALDEV,[M:PTH0]CHGTYP,[M:PTH0]RCPDAT,
&                  WCPRAMT,WCPRAMT,WSTAT) From TRTDEV
      [M:PTH1]CPRAMT(NOL)=arr(WCPRAMT,10^-GDECPRI)
  Else
      [M:PTH1]CPRAMT(NOL)=WCPRAMT
  Endif
Else
  Raz [M:PTH1]STCNUM(NOL), [M:PTH1]CPRAMT(NOL)
  [M:PTH1]CPRCOE(NOL)=1
Endif
If [M:PTH1]CPRCOE(NOL)=0 [M:PTH1]CPRCOE(NOL)=1 Endif

[M:PTH1]NETCUR(NOL)=[M:PTH0]CUR

# Issue 84130 - 2012-09-28 by MUARN : coeff/cout modifiable si pas de SDC
If [M:PTH1]STCNUM(NOL)<> ""
  Diszo [PTH1]CPRAMT(NOL), CPRCOE(NOL), CPR(NOL)
Else
  Actzo [PTH1]CPRAMT(NOL), CPRCOE(NOL), CPR(NOL)
Endif

[M:PTH1]CPRCUR(NOL)=GLOCALDEV
#[M:PTH1]QUAFLG(NOL)=1                         # hcb V6CQ
If [M:PTH1]STOMGTCOD(NOL)>1
  If [F:PTR]PTRTYP<>6 | [F:PTR]PTRNUM<>GPTRNUM  : # Relecture transaction si nécessaire
    Read [PTR] PTR0=6;GPTRNUM : If fstat  Raz [F:PTR] : Endif
  Endif
  [M:PTH1]TRSFAM(NOL)=[F:PTR]TRSFAMDEF
   #  If [F:ITP]ITMREF<>""                     # hcb V6CQ
   #     [M:PTH1]QUAFLG(NOL)=[F:ITP]QUAFLG     # hcb V6CQ
   #  Else                                     # hcb V6CQ
   #     [M:PTH1]QUAFLG(NOL)=[F:ITF]QUAFLG     # hcb V6CQ
   #  Endif
Endif
#--------------------------------------------------------------#
# Point d'entrée CPRCOE pour changer le coefficient d'approche #
# ------------------------------------------------------------ #
# Variables utilisables par le point d'entrée :                #
# La classe [M:PTH1]                                           #
# Les classes [F:POP], [F:POQ] et [F:ITP]                      #
# NOL      : indice de la ligne en cours de traitement         #
# CPR(NOL) : Prix unitaire net                                 #
# WCPRCOE  : Coefficient d'approche trouvé                     #
# ------------------------------------------------------------ #
# Variable modifiable par le point d'entrée :                  #
# WCPRCOE contient le coefficient d'approche modifié           #
#--------------------------------------------------------------#
Local Decimal WCPRCOE : WCPRCOE=[M:PTH1]CPRCOE(NOL)
Gosub POINT_CPRCOE From SUBPTHA : # A cause de la version 120 (assurer la pérennité)
If WCPRCOE<>0  [M:PTH1]CPRCOE(NOL)=WCPRCOE : Endif
#-- Chargement ligne facturée
[M:PTH1]LININVFLG(NOL)=1
[M:PTH1]INVQTYSTU(NOL)=0
#----- Chargement codes taxe -----#
Call ALIVATCOD(2,[M:PTH0]BPSNUM,[M:PTH1]ITMREF(NOL),"PTH1",NOL) From TRTX3
#-----
If dim([M:PTH1]TSICOD1(NOL))>0 [M:PTH1]TSICOD1(NOL)=[F:ITM]TSICOD(0) : Endif
If dim([M:PTH1]TSICOD2(NOL))>0 [M:PTH1]TSICOD2(NOL)=[F:ITM]TSICOD(1) : Endif
If dim([M:PTH1]TSICOD3(NOL))>0 [M:PTH1]TSICOD3(NOL)=[F:ITM]TSICOD(2) : Endif
If dim([M:PTH1]TSICOD4(NOL))>0 [M:PTH1]TSICOD4(NOL)=[F:ITM]TSICOD(3) : Endif
If dim([M:PTH1]TSICOD5(NOL))>0 [M:PTH1]TSICOD5(NOL)=[F:ITM]TSICOD(4) : Endif
Gosub INIT_COMPTES_LIGNE From SUBPTHB
If [M:PTH1]LINPURTYP(NOL)=0
  Call D_LINPURTYP ([M:PTH1]LINPURTYP(NOL))  From SUBPTH  : # Chargement type d'achat
Endif
Affzo [PTH1]NETCUR(NOL),LINACC1(NOL),LINACC2(NOL),LINPURTYP(NOL),VAT1(NOL),
&           VAT2(NOL),VAT3(NOL)
Return

$AB2_ITMREF
#--------------------------------#
# Avant bouton vers article site #
#--------------------------------#
If VALEUR <> ""
  GFLTITM=VALEUR
Endif
Return

$BB2_ITMREF
#--------------------------------#
# Après bouton vers article site #
#--------------------------------#
Raz GFLTITM
Return


Subprog IB_ITMDES
#----------------------------------#
# Initialisation bouton "Articles" #
#----------------------------------#
Raz GBOUT3, GBOUT4, GBOUT5, GBOUT6
GBOUT1=mess(22,198,1)

Call IB_NOTECHECK([M:PTH1]ITMREF(nolign-1),"ITMREF",2) From TRTNTSCTL # product notes  EWI 86291
End

Subprog AS_ITMDES(VALEUR)
#--------------------------#
# Avant saisie désignation #
#--------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
#If [M:PTH1]POHNUM(NOL)<>"" | [M:PTH0]BETFCY=2 mkstat=2 : End : Endif
End

$AB1_ITMDES
#------------------------------------#
# Avant exécution du tunnel Articles #
#------------------------------------#
Local Shortint NOL : NOL=nolign-1
Return

$BB1_ITMDES
#------------------------------------#
# Après exécution du tunnel Articles #
#------------------------------------#
#----- Relecture article si celui-ci a été changé par le tunnel -----#
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL)
  If fstat  Raz [F:ITM] : Endif
Endif
Return

Subprog IB_ITMDES1
#----------------------------------#
# Initialisation bouton "Articles" #
#----------------------------------#
Raz GBOUT2, GBOUT3, GBOUT4, GBOUT5, GBOUT6
GBOUT1=mess(22,198,1)
End

Subprog AS_ITMDES1(VALEUR)
#---------------------------#
# Avant saisie désignation1 #
#---------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
#If [M:PTH1]POHNUM(NOL)<>"" | [M:PTH0]BETFCY=2 mkstat=2 : End : Endif
End


Subprog AS_UOM(VALEUR)
#------------------#
# Avant saisie UOM #
#------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If GMODIF = 0 : mkstat = 2 : End : Endif
If [M:PTH1]CREFLG (NOL) <> 0 : mkstat = 2 : Endif
End

Subprog AM_UOM(VALEUR)
#-----------------#
# Après modif UOM #
#-----------------#
Variable Char     VALEUR()
Local Decimal  WPRIPUR, WCPRAMT, WUOMSTUCOE # Issue 70985 - 2012-04-10 by MUARN : landedcost
#-----
Local    Shortint NOL             : NOL   =nolign-1
Local    Char     WUNIT1(GLONUOM) : WUNIT1=[M:PTH1]UOM(NOL)
Local    Decimal  WCOEF1          : WCOEF1=[M:PTH1]UOMSTUCOE(NOL)
Local    Integer  OK
Local    Char     WUOM  (GLONUOM)
Local    Decimal  WCOEFF
Local    Integer  LRET
Local    Decimal  WQTYUOM, WQTYSTU, NEWQTY, NEWCOEFF, NEWMAXQTY
Local    Decimal  WOLD_UOMPUUCOE : [L]WOLD_UOMPUUCOE=[M:PTH1]UOMPUUCOE(NOL)
Local    Decimal  WOLD_QTYUOM    : [L]WOLD_QTYUOM   =[M:PTH1]QTYUOM   (NOL)
Local    Decimal  WOLD_QTYPUU    : [L]WOLD_QTYPUU   =[M:PTH1]QTYPUU   (NOL)
Local    Decimal  WOLD_QTYSTU    : [L]WOLD_QTYSTU   =[M:PTH1]QTYSTU   (NOL)

#-----
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif
If [F:ITP]ITMREF<>[M:PTH1]ITMREF(NOL) | [F:ITP]BPSNUM<>[M:PTH0]BPSNUM
  Read [ITP] ITP0=[M:PTH1]ITMREF(NOL);[M:PTH0]BPSNUM : If fstat  Raz [F:ITP] : Endif
Endif
If [F:PTR]PTRTYP<>6 | [F:PTR]PTRNUM<>GPTRNUM
  Read [PTR] PTR0=6;GPTRNUM : If fstat  Raz [F:PTR] : Endif
Endif
#---------------------------------------------------------------------#
# l'unité saisie fait-elle partie des unités autorisées en fonction   #
# de la transaction uniquement si article géré en stock               #
#---------------------------------------------------------------------#
If [F:PTR]UOMSAIFLG=1 & [M:PTH1]STOMGTCOD(NOL)>1
  If (VALEUR<>[F:ITP]PUU & [F:ITP]PUU<>"") | VALEUR<>[F:ITM]PUU | VALEUR <> [F:ITM]STU
    mkstat=2 : End
  Endif
Endif
#-----
[L]WCOEFF=[M:PTH1]UOMSTUCOE(NOL)
[L]WUOM  =VALEUR
Gosub DIS_COEFF From SUBPTHB : If mkstat  End : Endif
#-------------------------------------------------------------------#
# si ligne reception avec numéro commande voir a recuperer le coeff #
# sinon recherche du coefficient                                    #
# WCOEFF : contient UOMSTUCOE                                       #
#-------------------------------------------------------------------#
If [M:PTH1]POHNUM(NOL)<>""
  If VALEUR=[F:POQ]STU
    [L]WCOEFF=1
  Elsif VALEUR=[F:POQ]UOM | VALEUR=[F:POQ]PUU
    If VALEUR=[F:POQ]UOM
      GBIDD3=[F:POQ]QTYUOM*[L]WCOEFF
    Else
      GBIDD3=[F:POQ]QTYPUU*[L]WCOEFF
    Endif
    Call QTEARR(GBIDD3,[F:POQ]STU) From TRTDIV
    #----- Si on ne retrouve pas la même qté US, recalcul du coefficient ! -----#
    If GBIDD3<>[F:POQ]QTYSTU
      If VALEUR=[F:POQ]UOM
        [L]WCOEFF=arr([F:POQ]QTYSTU/[F:POQ]QTYUOM,0.00000001)
      Else
        [L]WCOEFF=arr([F:POQ]QTYSTU/[F:POQ]QTYPUU,0.00000001)
      Endif
      If [L]WCOEFF=0  [L]WCOEFF=1 : Endif
    Endif
    #-----
  Endif
Endif
#----- Si le coef est différent recalcul de la qté en UC à partir de l'US -----#
If [L]WCOEFF<>[L]WCOEF1
  [L]WQTYUOM=[M:PTH1]QTYSTU(NOL)/[L]WCOEFF
  Call QTEARR([L]WQTYUOM,[L]WUOM) From TRTDIV
  #----- Contrôle si la quantité UC génère une qté US arrondie -----#
  If [L]WUOM<>[M:PTH1]STU(NOL)
    Call STKCTRCOE([L]WQTYUOM,[L]WCOEFF,[M:PTH1]STU(NOL),LRET) From STKACT
    If LRET=0  mkstat=2 : End : Endif
  Endif
  #----- Contrôle si la qté US recalculée est identique -----#
  [L]WQTYSTU=[L]WQTYUOM*[L]WCOEFF
  Call QTEARR([L]WQTYSTU,[M:PTH1]STU(NOL)) From TRTDIV
  If [L]WQTYSTU<>[M:PTH1]QTYSTU(NOL)
    Call MESSAGE(mess(191,194,1)-num$([M:PTH1]QTYSTU(NOL))-"-->"-num$([L]WQTYSTU)-[M:PTH1]STU(NOL)) From GESECRAN
  Endif
  #----- Dans tous les cas calcul qté en UA et coeff UOMPUU -----#
  [M:PTH1]UOMSTUCOE(NOL)=[L]WCOEFF
  [M:PTH1]QTYUOM   (NOL)=[L]WQTYUOM
  [M:PTH1]QTYSTU   (NOL)=[L]WQTYSTU
  # Issue 79461 - 2012-01-20 by VPO : pb calcul qtypuu
  # trop tôt : [M:PTH1]UOM n'est pas affecté
  #Gosub CAL_QTYPUU From SUBPTHB
Endif
#----- Calcul de la quantité max avec contrôle -----#
[L]NEWQTY    =[M:PTH1]QTYUOM(NOL)
[L]NEWCOEFF  =[M:PTH1]UOMSTUCOE(NOL)
Gosub CALCTL_QTYUS
If mkstat
  [M:PTH1]UOMSTUCOE(NOL)=[L]WCOEF1
  [M:PTH1]UOMPUUCOE(NOL)=[L]WOLD_UOMPUUCOE
  [M:PTH1]QTYUOM   (NOL)=[L]WOLD_QTYUOM
  [M:PTH1]QTYPUU   (NOL)=[L]WOLD_QTYPUU
  [M:PTH1]QTYSTU   (NOL)=[L]WOLD_QTYSTU
  End
Endif
# Issue 79461 - 2012-01-20 by VPO : pb calcul qtypuu
If [L]WCOEFF<>[L]WCOEF1
  [M:PTH1]UOM(NOL)=VALEUR
  Gosub CAL_QTYPUU From SUBPTHB
Endif

# Issue 106506 - 2015-04-21 by SR : Landed Cost
If [M:PTH1]SHIPNUM(NOL) <> ""
   Gosub MAJ_WSHDSOLDE From SUBPTHB
Endif
# End issue 106506

#-----
Affzo [PTH1]QTYUOM(NOL), QTYSTU(NOL), UOMSTUCOE(NOL)

#--- Bug 93894
If [F:ITM]STOMGTCOD>1 & !find(VALEUR,[F:ITM]STU,[F:ITM]PCU)
   [M:ENTW]WZONPCU = "STU"
   [M:ENTW]WZONQUC = "QTYSTU"
Else
   [M:ENTW]WZONPCU = "UOM"
   [M:ENTW]WZONQUC = "QTYUOM"
Endif
#---

#----- Recherche tarif ? après modif unité si réception directe -----#
If [M:PTH1]POHNUM(NOL)="" & [M:PTH1]SDHNUM(NOL)="" & [M:PTH1]CREFLG(NOL)=0
  [M:PTH1]UOM(NOL)=VALEUR
  If [M:PTH1]LINFLG(NOL)=1
    OK=2 : Call OUINON(mess(63,196,1),OK) From GESECRAN
    If OK=2
      Call INI_TARIF(NOL,"UOM") From SUBPTHB
    Else
      Call REAJUST_TARIF("PTH1",NOL,WUNIT1,VALEUR,WCOEF1,[M:PTH1]UOMSTUCOE(NOL)) From TRTACHPRI1
    Endif
  Else
    Call INI_TARIF(NOL,"UOM") From SUBPTHB
  Endif
Else
  # Issue 119281 - 2017-01-05 by SR : Possibilité de ne pas réjuster les montants unistaires
  Local Char WZON(10) : WZON = "UOM"
  GPE = 1
  Gosub POINT_NOREAJUST From SUBPTHA
  If GPE
    Call REAJUST_TARIF("PTH1",NOL,WUNIT1,VALEUR,WCOEF1,[M:PTH1]UOMSTUCOE(NOL)) From TRTACHPRI1
  Endif
  # End issue 119281
  # Issue 107177 - 2015-10-21 by MUARN : A faire en APRES_NBLIG
  #If [M:PTH1]LINTYP(NOL)=2
  #  Call CALCUL_COMPOSANTS(NOL) From SUBPTHD
  #Endif
Endif
nolign=NOL+1
#----- Si réception du Service (cas d'un OF) de sous-traitance, effacement indicateur stock -----#
#If [F:ITM]SCSFLG=2 & [M:PTH1]WRKMOTEUR(NOL)=2  Raz [M:PTH1]WSTOFLG(NOL) : Endif # FQ 55135 GA 05/2009
#If find([M:PTH1]VCRTYPORI(NOL),10,36)   Raz [M:PTH1]WSTOFLG(NOL) : Endif        # Issue 95550 GA 01/2014
If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) Raz [M:PTH1]WSTOFLG(NOL) : Endif
End

Subprog AS_QTYUOM(VALEUR)
#----------------------#
# Avant saisie qté uom #
#----------------------#
Variable Decimal VALEUR
Local    Shortint NOL     : NOL=nolign-1
If [F:ITM]SCSFLG=2 & [M:PTH1]CREFLG(NOL)<>0
  mkstat =2
Endif
End

Subprog C_QTYUOM(VALEUR)
#--------------#
# Controle qty #
#--------------#
Variable Decimal  VALEUR
# Suppression de l'option + dans le masque
# Qui n'est pas traitée en import
If VALEUR <= 0 : mkstat=2 : End : Endif
End

Subprog AM_QTYUOM(VALEUR)
#-----------------#
# Après modif qty #
#-----------------#
Variable Decimal VALEUR
Local    Shortint NOL     : NOL=nolign-1
Local    Decimal  WQTYPUU : WQTYPUU=[M:PTH1]QTYPUU(NOL)
Local    Decimal  WQTYSTU : WQTYQTU=[M:PTH1]QTYSTU(NOL)
Local    Integer  OK, WSTAT
Local    Decimal  NEWCOEFF, OLDWCOEFF, NEWQTY, NEWMAXQTY
Local    Shortint J

# Issue 84130 - 2012-12-12 by MUARN : landed cost-poids et volume
Local    Decimal  WOLDQTYSTU
WOLDQTYSTU = [M:PTH1]QTYSTU(NOL)
# Issue 84130 - 2013-02-05 by MUARN : landed cost
Local Integer WRET
#-----
# Issue 101375 - 2014-08-12 by CCC
If dim(GOLDQTY)<0 : Global Decimal GOLDQTY : Endif
If GOLDQTY=0
    GOLDQTY=[M:PTH1]QTYUOM(NOL)
Elsif GOLDQTY=VALEUR
    GOLDQTY=0
Endif

[L]NEWQTY    =VALEUR
[L]NEWCOEFF  =[M:PTH1]UOMSTUCOE(NOL)
#-----
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif

#--- Contrôle si la quantité UC génère une qté US arrondie
Local Integer LRET
If [M:PTH1]UOM(NOL)<>[M:PTH1]STU(NOL)
   Call STKCTRCOE(VALEUR,[M:PTH1]UOMSTUCOE(NOL),[M:PTH1]STU(NOL),LRET) From STKACT
   If LRET=0 : mkstat=2 : End : Endif
Endif

#----- Calcul de la quantité max avec contrôle
Gosub CALCTL_QTYUS
If mkstat  End  Else  Affzo [PTH1]QTYSTU(NOL) : Endif
#----- Mise à jour indicateur de solde de la ligne de réception (ligne facturée) -----#
# Issue 90221 - 2013-06-03 by SR : si la ligne de commande est facturée, on solde la ligne de réception
If [M:PTH1]INVQTYSTU(NOL)<[M:PTH1]QTYSTU(NOL) & [F:POQ]LININVFLG <> 2
  [M:PTH1]LININVFLG(NOL)=1
# Issue 104651 - 2014-12-10 by MUARN : ne pas faire si POHCLE = 3
Elsif GPOHCLE<> 3
  [M:PTH1]LININVFLG(NOL)=2
Endif
Affzo [PTH1]LININVFLG(NOL)
# Issue 106506 - 2015-04-21 by SR : Landed Cost
If [M:PTH1]SHIPNUM(NOL) <> ""
   [M:PTH1]SHDQTYSTU(NOL) +=WOLDQTYSTU
   [M:PTH1]SHDQTYSTU(NOL) -=[M:PTH1]QTYSTU(NOL)
   [M:PTH1]SHDQTYSTU(NOL) = max(0,[M:PTH1]SHDQTYSTU(NOL))
   Gosub MAJ_WSHDSOLDE From SUBPTHB
Endif
# End issue 106506
#-----
If [M:PTH0]BETFCY=2 & [M:PTH1]SDHNUM(NOL)<>"" &
& [M:PTH1]QTYSTU(NOL)<>[M:PTH1]SDDQTY(NOL)
  #- avertissement car la quantité a été modifiée par rapport à la livraison -#
  Call MESSAGE (mess(281,194,1)) From GESECRAN
Endif
#--- Attention acceptation de la valeur ---#
#--- Les blocages sont effectués avant  ---#
[M:PTH1]QTYUOM(NOL)=VALEUR
Gosub CAL_QTYPUU From SUBPTHB
#----- Recherche tarif ? après modif quantité si réception directe -----#
If [M:PTH1]POHNUM(NOL)="" & [M:PTH1]SDHNUM(NOL)="" & [M:PTH1]CREFLG(NOL)=0
  If [M:PTH1]LINFLG(NOL)=1
    OK=2 : Call OUINON(mess(63,196,1),OK) From GESECRAN
    If OK=2
      Call INI_TARIF(NOL,"QTYUOM") From SUBPTHB
    Else
      Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),1,1) From TRTACHPRI1
    Endif
  Else
    Call INI_TARIF(NOL,"QTYUOM") From SUBPTHB
  Endif
#-----
Else
 # Issue 119281 - 2017-01-05 by SR : Possibilité de ne pas réjuster les montants unistaires
  Local Char WZON(10) : WZON = "QTYUOM"
  GPE = 1
  Gosub POINT_NOREAJUST From SUBPTHA
  If GPE
    Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),1,1) From TRTACHPRI1
  Endif
  # End issue 119281
  # Issue 107177 - 2015-10-21 by MUARN : A faire en APRES_NBLIG
  #If [M:PTH1]LINTYP(NOL)=2
  #  Call CALCUL_COMPOSANTS(NOL) From SUBPTHD
  #Endif
Endif
# Issue 101375 - 2014-07-11 by CCC
##----- Si réception du Service (cas d'un OF) de sous-traitance, effacement indicateur stock -----#
##If [F:ITM]SCSFLG=2 & [M:PTH1]WRKMOTEUR(NOL)=2  Raz [M:PTH1]WSTOFLG(NOL) : Endif # FQ 55135 GA 05/2009
##If find([M:PTH1]VCRTYPORI(NOL),10,36)   Raz [M:PTH1]WSTOFLG(NOL) : Endif        # Issue 95550 GA 01/2014
#If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) Raz [M:PTH1]WSTOFLG(NOL) : Endif

# Issue 84130 - 2012-12-12 by MUARN : landed cost - poids et volume
If [M:PTH1]LINTYP(NOL)<3
  If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
    Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
  Endif
  Call CONVERT_VOUWEU("PTH1",NOL,[M:PTH1]LINWEU(NOL),[M:PTH1]LINVOU(NOL),[M:PTH1]QTYSTU(NOL),WOLDQTYSTU) From STCLIB
Endif
If !GIMPORT Affzo [PTH1]QTYVOU(NOL),QTYWEU(NOL) : Endif

End

$CALCTL_QTYUS
#-----------------------------#
# Calcul des quantités en US  #
# Contrôle des quantités      #
#-----------------------------#
[L]NEWQTY = [L]NEWQTY * [L]NEWCOEFF
Raz [L]NEWMAXQTY
If [M:PTH1]POHNUM(NOL)<>""
  Gosub CAL_MAXQTYRCP  From SUBPTHB
Else
  [L]NEWMAXQTY=99999999999.999999
Endif
Raz mkstat
If [M:PTH1]POHNUM(NOL)<>""
  Gosub CTL_QTY From SUBPTHB
Endif
#-- Si contrôle OK acception de la quantité
#-- Positionnement maxqte
#-- Positionnement du solde
If !mkstat
  Call QTEARR([L]NEWQTY,[M:PTH1]STU(NOL)) From TRTDIV
  [M:PTH1]QTYSTU(NOL)   = [L]NEWQTY
  [M:PTH1]UOMSTUCOE(NOL)= [L]NEWCOEFF
  [M:PTH1]MAXQTYRCP(NOL)= [L]NEWMAXQTY
  #--- Position du solde (J est déclaré et contient l'ancienne valeur)
  Gosub POSITION_SOLDE From SUBPTHB
  If [M:PTH1]WSOLDE(NOL)<>J & !GIMPORT  Affzo [PTH1]WSOLDE(NOL) : Endif
Endif
Return

Subprog AS_UOMSTUCOE(VALEUR)
#------------------------#
# Avant saisie UOMSTUCOE #
#------------------------#
Variable Decimal  VALEUR
If [F:ITM]SCSFLG=2 | [M:PTH1]UOM(nolign-1)=[M:PTH1]STU(nolign-1)
  mkstat=2 : End
Endif
End

Subprog AM_UOMSTUCOE(VALEUR)
#-------------------#
# Après modif coeff #
#-------------------#
Variable Decimal  VALEUR
#-----
Local    Shortint NOL        : NOL       =nolign-1
Local    Decimal  WQTYPUU    : WQTYPUU   =[M:PTH1]QTYPUU(NOL)
Local    Decimal  WQTYSTU    : WQTYSTU   =[M:PTH1]QTYSTU(NOL)
Local    Decimal  WUOMSTUCOE : WUOMSTUCOE=[M:PTH1]UOMSTUCOE(NOL)
Local    Integer  OK, WSTAT
Local    Decimal  NEWQTY, NEWCOEFF, NEWMAXQTY

# Issue 84130 - 2012-12-12 by MUARN : landed cost-poids et volume
Local    Decimal  WOLDQTYSTU
WOLDQTYSTU = [M:PTH1]QTYSTU(NOL)

#-----
If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
  Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
Endif
#-----
[L]NEWQTY  =[M:PTH1]QTYUOM(NOL)
[L]NEWCOEFF= VALEUR
If [M:PTH1]UOM(NOL)=[M:PTH1]STU(NOL)
 [L]NEWCOEFF=1
Endif

#--- Contrôle si le coef UC/US génère une qté US arrondie
Local Integer LRET
If [M:PTH1]UOM(NOL)<>[M:PTH1]STU(NOL)
   Call STKCTRCOE([M:PTH1]QTYUOM(NOL),VALEUR,[M:PTH1]STU(NOL),LRET) From STKACT
   If LRET=0 : mkstat=2 : End : Endif
Endif

Gosub CALCTL_QTYUS
If mkstat : End : Endif
Gosub CAL_QTYPUU From SUBPTHB
Affzo [PTH1]QTYSTU(NOL)
#----- Réajustement tarif si commande ou livraison -----#
If [M:PTH1]POHNUM(NOL)<>"" | [M:PTH1]SDHNUM(NOL)<>""
  # Issue 119281 - 2017-01-05 by SR : Possibilité de ne pas réjuster les montants unistaires
  Local Char WZON(10) : WZON = "UOMSTUCOE"
  GPE = 1
  Gosub POINT_NOREAJUST From SUBPTHA
  If GPE
    If WUOMSTUCOE>max(WQTYPUU,WQTYSTU)
      Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),
&                       WUOMSTUCOE,VALEUR) From TRTACHPRI1
    Elsif WQTYSTU>WQTYPUU
      Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),
&                       WQTYSTU,[M:PTH1]QTYSTU(NOL)) From TRTACHPRI1
    Else
      Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),
&                       WQTYPUU,[M:PTH1]QTYPUU(NOL)) From TRTACHPRI1
    Endif
  Endif
  # End issue 119281
  # Issue 107177 - 2015-10-21 by MUARN : A faire en APRES_NBLIG
  #If [M:PTH1]LINTYP(NOL)=2
  #  Call CALCUL_COMPOSANTS(NOL) From SUBPTHD
  #Endif
Endif
#----- Si réception du Service (cas d'un OF) de sous-traitance, effacement indicateur stock -----#
#If [F:ITM]SCSFLG=2 & [M:PTH1]WRKMOTEUR(NOL)=2  Raz [M:PTH1]WSTOFLG(NOL) : Endif # FQ 55135 GA 05/2009
#If find([M:PTH1]VCRTYPORI(NOL),10,36)   Raz [M:PTH1]WSTOFLG(NOL) : Endif        # Issue 95550 GA 01/2014
If find([M:PTH1]VCRTYPORI(NOL),10,36) & find([M:PTH1]WRKMOTEUR(NOL),2,3) Raz [M:PTH1]WSTOFLG(NOL) : Endif

# Issue 84130 - 2012-12-12 by MUARN : landed cost - poids et volume
If [M:PTH1]LINTYP(NOL)<3
  If [F:ITM]ITMREF<>[M:PTH1]ITMREF(NOL)
    Read [ITM] ITM0=[M:PTH1]ITMREF(NOL) : If fstat  Raz [F:ITM] : Endif
  Endif
  Call CONVERT_VOUWEU("PTH1",NOL,[M:PTH1]LINWEU(NOL),[M:PTH1]LINVOU(NOL),[M:PTH1]QTYSTU(NOL),WOLDQTYSTU) From STCLIB
Endif
If !GIMPORT Affzo [PTH1]QTYVOU(NOL),QTYWEU(NOL) : Endif

End

Subprog IB_SLO
#--------------------------------------------------#
# Initialisation bouton "Nouveau" pour le sous-lot #
#--------------------------------------------------#
GBOUT1=mess(70,151,1)
End

Subprog B1_SLO(VALEUR)
#-------------------------------------#
# Bouton 1 "Nouveau" pour le sous-lot #
#-------------------------------------#
Variable Char    VALEUR()
Call RECLASTSLO([M:PTH1]ITMREF(nolign-1),[M:PTH1]LOT(nolign-1),"","",VALEUR) From STKLIB
End

Subprog AM_SLO(VALEUR)
#-------------------------------------------#
# Contrôle sous-lot et positionnement SLOTF #
#-------------------------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If VALEUR<>""
  If [M:PTH1]SDHNUM(NOL)<>""
    Call STKCTRSLO(VALEUR, [M:PTH1]NBSLO(NOL), [M:PTH1]LOT(NOL),
&                 [M:PTH1]ITMREF(NOL),[M:PTH1]BPSLOT(NOL),[M:PTH1]GESLOT(NOL),
&                 [M:PTH1]SDHNUM(NOL), 4, [M:PTH1]SDDLIN(NOL), 0,
&                 [M:PTH0]PRHFCY, [M:PTH1]SLOF(NOL)) From STKACT
  Else
    Call STKCTRSLO(VALEUR, [M:PTH1]NBSLO(NOL), [M:PTH1]LOT(NOL),
&                 [M:PTH1]ITMREF(NOL),[M:PTH1]BPSLOT(NOL),[M:PTH1]GESLOT(NOL),"", 0, 0, 0,
&                 [M:PTH0]PRHFCY, [M:PTH1]SLOF(NOL)) From STKACT
  Endif
  Affzo [PTH1]SLOF(NOL)
Endif
End

Subprog AM_NBSLO(VALEUR)
#--------------------------#
# Après modif nbr sous-lot #
#--------------------------#
Variable Decimal VALEUR
Local Shortint NOL : NOL=nolign-1
Call STKCTRNBSLO(VALEUR, [M:PTH1]UOM(NOL), [M:PTH1]QTYUOM(NOL)) From STKACT
End


Subprog AS_WRH(VALEUR)
Variable Char    VALEUR()
If GWRHOBY=2
  VALEUR = [M:PTH0]WRHE : mkstat=2 : End
Endif
If VALEUR=""
  VALEUR = [M:PTH0]WRHE
Endif
End

Subprog C_WRH(VALEUR)
Variable Char    VALEUR()
If VALEUR<>""
  Read [ITW]ITW0=[M]ITMREF(nolign-1);VALEUR
  If fstat
     GMESSAGE=[M]ITMREF(nolign-1)-":"-mess(343,184,1) : mkstat=2
  Endif
Endif
End

Subprog AM_WRH(VALEUR)
Variable Char    VALEUR()
If [M:PTH1]WRH(nolign-1)<>""
   Raz [M:PTH1]LOC(nolign-1)
Endif
End

Subprog IB_LOC
#-------------------------#
# Init bouton emplacement #
#-------------------------#
GBOUT2=mess(83,196,1)
GBOUT3=mess(218,198,1)
End


Subprog C_LOCTYP(VALEUR)
#---------------------------#
# Controle type emplacement #
#---------------------------#
Variable Char    VALEUR()
If VALEUR <> ""
  Read [TLO]TLO0=[M:PTH0]PRHFCY;VALEUR
  If fstat
     GMESSAGE=mess(245,192,1)-[M:PTH0]PRHFCY : mkstat = 2  : End
  Endif
# test si type quai autorisé
  If [F:PTR]PTRTYP<>6 | [F:PTR]PTRNUM<>GPTRNUM  : # Relecture transaction si nécessaire
    Read [PTR] PTR0=6;GPTRNUM : If fstat  Raz [F:PTR] : Endif
  Endif
  If [F:PTR]SRGWAIFLG <> 2 & [F:TLO]LOCCAT = 2
    GMESSAGE = mess(854,196,1) : mkstat = 2 : End
  Endif
Endif
#--- Bug 72649
If [M:PTH1]LOCTYP(nolign-1)<>VALEUR
   Call RAZLOC([M:PTH1]LOC(nolign-1),[M:PTH1]WLOCSEQ(nolign-1)) From STKACT
Endif
#---
End

$AB1_LOC
#--------------#
# avant tunnel #
#--------------#
GLOCSEL = "LOCTYP='"+[M:PTH1]LOCTYP(nolign-1)+"'"
Return

$BB1_LOC
#--------------#
# apres tunnel #
#--------------#
Raz GLOCSEL
Return


Subprog AS_RRRQTYSTU(VALEUR)
#-------------------------#
# Avant saisie qté litige #
#-------------------------#
Variable Decimal VALEUR
Local    Shortint NOL : NOL=nolign-1
#----- Pas de saisie si géré en stock ou sous-traitance déjà traitée -----#
If [M:PTH1]STOMGTCOD(NOL)>1
  mkstat=2 : End
Elsif [F:ITM]SCSFLG=2 & ([M:PTH1]WRKMOTEUR(NOL)=2 | [M:PTH1]CREFLG(NOL)<>0)
  mkstat=2 : End
Endif
End

Subprog C_RRRQTYSTU(VALEUR)
#------------------------#
# Controle Qté en litige #
#------------------------#
Variable Decimal VALEUR
Local    Shortint NOL     : NOL=nolign-1
# Suppression de l'option + dans le masque
# Qui n'est pas traitée en import
If VALEUR < 0 : mkstat=2 : End : Endif
If VALEUR > [M:PTH1]QTYSTU (NOL)
  GMESSAGE = mess(114,194,1)
  mkstat =2
Endif
End

Subprog AM_RRRQTYSTU(VALEUR)
#---------------------------#
# Après-modif Qté en litige #
#---------------------------#
Variable Decimal VALEUR
Local    Shortint NOL     : NOL=nolign-1
#--- Calcul de la quantité en UA
#--- Dans tous les cas calcul qté en UA ---#
If [M:PTH1]PUU(NOL)=[M:PTH1]STU(NOL)
  [M:PTH1]RRRQTYPUU(NOL)=VALEUR
Else
  Call PCAL_QTY(VALEUR,[M:PTH1]STU(NOL),[M:PTH1]RRRQTYPUU(NOL),[M:PTH1]PUU(NOL),[M:PTH1]ITMREF(NOL),
&        [M:PTH0]BPSNUM,1,GBIDD3) From TRTACHQTE1
Endif
End

Subprog AS_WSOLDE(VALEUR)
#-----------------------------------------#
# Avant saisie du solde                   #
#-----------------------------------------#
# GPOHCLE=1 Si égalité ou supérieur       #
# GPOHCLE=2 A la demande                  #
# GPOHCLE=3 Jamais                        #
# GPOHCLE=4 Suivant tolérence             #
# GPOHCLE=5 Tolérence + reste à la demande#
#-----------------------------------------#
Variable Integer VALEUR
Local    Shortint NOL     : NOL=nolign-1
If GPOHCLE=3 | [M:PTH1]POHNUM(NOL)=""    mkstat=2 : End : Endif
If [M:PTH1]POHTYP=2 & [M:PTH0]BETFCY=2
  If [M:PTH1]POHNUM(NOL)<>""
    If [F:POH]POHNUM<>[M:PTH1]POHNUM(NOL)
      Read [POH] POH0=[M:PTH1]POHNUM(NOL) : If fstat  Raz [F:POH] : Endif
    Endif
    If [F:POH]SALFCY<>""  mkstat=2 : End : Endif
  Endif
  If [M:PTH1]MAXQTYRCP(NOL)<=0  mkstat=2 : End : Endif
Endif
# Solde si égalité ou supérieur
If GPOHCLE=1 & [M:PTH1]MAXQTYRCP(NOL)<=0 mkstat=2 : End : Endif
# Solde suivant % tolérance
If GPOHCLE=4
  GBIDD1=[M:PTH1]MAXQTYRCP(NOL)
  If GBIDD1<=0 | abs((GBIDD1/[F:POQ]QTYSTU)*100)<=[F:ITM]MINRMNPRC
    mkstat=2
  Endif
Endif
# Issue 99235 - 2014-04-16 by MUARN : non modifiable en commande ouverte et modification
If [M:PTH1]POHTYP(NOL)=2 & [M:PTH1]CREFLG(NOL)<>0
  mkstat =2
Endif
End

Subprog AM_WSOLDE(VALEUR)
#-------------------#
# Après modif solde #
#-------------------#
Variable Integer VALEUR
Local  Integer  NOL, J

NOL=nolign-1
#--------------------------#
# Autorisation solde vente #
#--------------------------#
If [M:PTH1]POHTYP(NOL)=1 & [M:PTH0]BETFCY=2 & [M:PTH1]POHNUM(NOL)<>"" & VALEUR=2
  #----- Lecture ligne commande quantités si nécessaire -----#
  If [F:POQ]POHNUM<>[M:PTH1]POHNUM(NOL) | [F:POQ]POPLIN<>[M:PTH1]POPLIN(NOL)
&   |[F:POQ]POQSEQ<>[M:PTH1]POQSEQ(NOL)
    Read [POQ] POQ0=[M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat  Raz [F:POQ] : Endif
  Endif
  Call CTLMAJSOP("S",[F:POQ]LINOCNNUM,[F:POQ]OCNLIN,[F:POQ]OCNLIN,GBIDI2) From TRTVENISOC
  #-- Si commande non soldée et GBIDI2<>0 solde interdit
  If [F:SOQ]SOQSTA<>3 & GBIDI2<>0
    GERR=1 : mkstat=2 : End
  Endif
  Raz GMESSAGE
Endif
[M:PTH1]WSOLDE(NOL)=VALEUR
Gosub REAJUST_WSOLDE From SUBPTHB
# Issue 106506 - 2015-04-23 by SR : Landed Cost
If [M:PTH1]SHIPNUM(NOL) <> ""
   If VALEUR = 2
     [M:PTH1]WSHDSOLDE(NOL) = 2
   Else
       Gosub MAJ_WSHDSOLDE From SUBPTHB
   Endif
Endif
# End issue 106506
End

Subprog AM_PJT(VALEUR)
#------------------------------------#
# Après modification du code affaire #
#------------------------------------#
Variable Char    VALEUR()
Local   Shortint NOL : NOL=nolign-1
#----- Recherche tarif ? si réception directe -----#
[M:PTH1]PJT(NOL)=VALEUR
If [M:PTH1]POHNUM(NOL)="" & [M:PTH1]SDHNUM(NOL)="" & [M:PTH1]CREFLG(NOL)=0
  If [M:PTH1]LINFLG(NOL)=1
    Local Integer OK
    OK=2 : Call OUINON(mess(63,196,1),OK) From GESECRAN
    If OK=2
      Call INI_TARIF(NOL,"PJT") From SUBPTHB
    Endif
  Else
    Call INI_TARIF(NOL,"PJT") From SUBPTHB
  Endif
Endif
End

Subprog PASLINPTH(DISCRGNUM)
#--------------------------------------#
# Avant saisie des remises/frais tarif #
#--------------------------------------#
Value Integer DISCRGNUM
#-----
Local Shortint NOL : NOL=nolign-1
If [M:PTH1]LINTYP(NOL)=2  mkstat=2 : End : Endif
If DISCRGNUM<1 | DISCRGNUM>9  End : Endif

# Issue 87192 - 2013-01-16 by MUARN : Remise et tarif en réception directe
#If GMODIF<>2                 |
#&  GCOLREM(DISCRGNUM-1)=""   |
#&  GINVDTALIN(DISCRGNUM-1)=0 |
#&  GNPRNOTFLG(DISCRGNUM-1)=2
#  mkstat=2 : End
#Endif
# Issue 89350 - 2013-04-16 by MUARN : ne pas contrôler en import
# Issue 102827 - 2014-11-03 by MUARN : remise/frais nom modifiable après création de réception directe
If GMODIF <>2 | (GCOLREM(DISCRGNUM-1)="" & !GIMPORT) | [M:PTH1]POHNUM(NOL)<> ""
&  | ([M:PTH1]CREFLG(NOL)<>0 & [M:PTH1]POHNUM(NOL)="")
  mkstat=2
Endif

End

Subprog IB_GROPRI
#-----------------------------------------------------------------------------------#
# Activation boutons "Tarifs", "Dernier prix", "Réinit.Prix", "Explication du prix" #
#-----------------------------------------------------------------------------------#
Raz GBOUT6 : # GBOUT2 est chargé par l'action SAIPURREN et géré par l'action INIREN
GBOUT1=mess(42,198,1) : GBOUT3=mess(24,198,1)
GBOUT4=mess(52,198,1) : GBOUT5=mess(386,198,1)
End

Subprog AS_GROPRI(VALEUR)
#-------------------#
# Avant saisie prix #
#-------------------#
Variable Decimal  VALEUR
Local    Shortint NOL : NOL=nolign-1
# Issue 102827 - 2014-11-03 by MUARN : prix nom modifiable après création de réception directe
If GMODIF<>2 | [M:PTH1]POHNUM(NOL)<>"" | [M:PTH1]SDHNUM(NOL)<>"" | [M:PTH1]LINTYP(NOL)=2 |
&  ([M:PTH1]CREFLG(NOL)<>0 & [M:PTH1]POHNUM(NOL)="")
  mkstat=2 : End
Endif
End

Subprog B4_GROPRI(VALEUR)
#------------------------#
# Bouton : "Réinit.Prix" #
#------------------------#
Variable Decimal  VALEUR
Local    Shortint NOL : NOL=nolign-1
Call INI_TARIF(NOL,"GROPRI") From SUBPTHB   : VALEUR=[M:PTH1]GROPRI(NOL)
mkstat=99
End

Subprog AP_GROPRI(VALEUR)
#-----------------------------------------------------------------#
# Après saisie du prix brut : Test si prix nul (sauf inter-sites) #
#-----------------------------------------------------------------#
Variable Decimal VALEUR
If VALEUR=0 & ([M:PTH0]BETFCY<>2 | [M:PTH0]BETCPY=2)
  Local Integer OK
  OK=2 : Call AVERTIR(mess(62,194,1),OK) From GESECRAN
  If OK=1  mkstat=1 : End : Endif
Endif
End

Subprog AS_LINACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub AS_LINACCX
End

Subprog C_LINACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub C_LINACCX
End

Subprog AM_LINACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub AM_LINACCX
End

Subprog AS_LINACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub AS_LINACCX
End

Subprog C_LINACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub C_LINACCX
End

Subprog AM_LINACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub AM_LINACCX
End

Subprog AS_LINACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub AS_LINACCX
End

Subprog C_LINACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub C_LINACCX
End

Subprog AM_LINACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub AM_LINACCX
End

Subprog AS_LINACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub AS_LINACCX
End

Subprog C_LINACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub C_LINACCX
End

Subprog AM_LINACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub AM_LINACCX
End

Subprog AS_LINACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub AS_LINACCX
End

Subprog C_LINACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub C_LINACCX
End

Subprog AM_LINACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub AM_LINACCX
End

Subprog AS_LINACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub AS_LINACCX
End

Subprog C_LINACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub C_LINACCX
End

Subprog AM_LINACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub AM_LINACCX
End

Subprog AS_LINACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub AS_LINACCX
End

Subprog C_LINACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub C_LINACCX
End

Subprog AM_LINACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub AM_LINACCX
End

Subprog AS_LINACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub AS_LINACCX
End

Subprog C_LINACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub C_LINACCX
End

Subprog AM_LINACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub AM_LINACCX
End

Subprog AS_LINACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub AS_LINACCX
End

Subprog C_LINACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub C_LINACCX
End

Subprog AM_LINACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub AM_LINACCX
End

Subprog AS_LINACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub AS_LINACCX
End

Subprog C_LINACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub C_LINACCX
End

Subprog AM_LINACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub AM_LINACCX
End

$AS_LINACCX
#-------------------------------------#
# Avant saisie commune aux 10 comptes #
#-------------------------------------#
If GMODIF<>2  mkstat=2 : Return : Endif
Call AVSAI_ACC(VALEUR,PLAN,"[M:PTH1]LINACC") From TRTX3CPT
Return

$C_LINACCX
#--------------------------------#
# Contrôle commun aux 10 comptes #
#--------------------------------#
Local    Shortint NOL : NOL=nolign-1
#-----
Call CTRL_ACC(VALEUR,PLAN,GFINRSP,[M:PTH0]RCPDAT,[M:PTH0]CUR,"[M:PTH1]LINACC") From TRTX3CPT
#-----
Return

$AM_LINACCX
#------------------------------------#
# Après modif commune aux 10 comptes #
#------------------------------------#
Local    Shortint I
Local    Shortint NOL : NOL=nolign-1
#-----
# Issue 106746 - 2015-04-02 by SR :
If GREP="C"
  For I=PLAN+1 To dim(GCOA)
      If I<=GNBCOA
         Assign "[M:PTH1]LINACC"+num$(I)+"(NOL)" With ""
      Else
         Break
      Endif
  Next
Endif
# End issue 106746
Call APMOD_ACC(VALEUR,PLAN,"[M:PTH1]LINACC") From TRTX3CPT
#-----
If [F:GAC]COA<>GCOA(PLAN) | [F:GAC]ACC<>VALEUR
   Read [GAC] GAC0=GCOA(PLAN);VALEUR : If fstat Raz [F:GAC] : Endif
Endif
If PLAN=1
  [M:PTH1]LINACC1(NOL)=VALEUR
  # Issue 85153 - 2012-10-19 by MUARN : réinitialisation du type après saisie d'un compte
  #If !varinit([M:PTH1]LINPURTYP,NOL)
    Call D_LINPURTYP ([M:PTH1]LINPURTYP(NOL)) From SUBPTH  : # Chargement type d'achat
    Affzo [M:PTH1]LINPURTYP(NOL)
  #Endif
Endif
Assign "[M:PTH1]LINACC"+num$(PLAN)+"(NOL)" With VALEUR
GBIDI2=1 : Gosub PREP_INIT_CCE From SUBPTHB
Return

Subprog D_LINPURTYP(VALEUR)
#--------------------------------------------------------------#
# Initialisation du type d'achat en fonction du compte général #
#--------------------------------------------------------------#
Variable Integer VALEUR
#----- Recherche compte général -----#
Local Char WACC(GLONGAC)
Call RECH_ACC(1,"[M:PTH1]LINACC",nolign-1,WACC) From TRTX3CPT
If WACC<>""
  If [F:GAC]VATIPT=5
    VALEUR=3
  Elsif [F:GAC]VATIPT=4
    VALEUR=2
  Else
    VALEUR=1
  Endif
Else
  VALEUR=1
Endif
End

Subprog AM_LINPURTYP(VALEUR)
#------------------------------------#
# Après modification du type d'achat #
#------------------------------------#
Variable Integer VALEUR
Local Integer OK
OK=2 : Call OUINON(mess(340,194,1),OK) From GESECRAN
If OK=2
  Local Integer  I
  Local Shortint NOL                  : NOL=nolign-1
  Local Char     SAV_LINACC1(GLONGAC) : SAV_LINACC1=[M:PTH1]LINACC1(NOL)
  Local Char     SAV_LINACC2(GLONGAC) : SAV_LINACC2=[M:PTH1]LINACC2(NOL)
  [M:PTH1]LINPURTYP(NOL)=VALEUR
  Gosub INIT_COMPTES_LIGNE  From SUBPTHB
  [M:PTH1]LINPURTYP(NOL)=VALEUR : # Modifié par le Gosub !
  # Issue 42104 - 2017-06-22 by MUARN : ne pas faire sinon on perd les données de la pièce auto (INIT_COMPTES_LIGNE)
  #If [M:PTH1]LINACC1(NOL)<>SAV_LINACC1
  #  Call AM_LINACC1([M:PTH1]LINACC1(NOL))
  #Endif
  #If [M:PTH1]LINACC2(NOL)<>SAV_LINACC2
  #  Call AM_LINACC2([M:PTH1]LINACC2(NOL))
  #Endif
  If !GIMPORT  Gosub AFFICH_LINACC : Endif
Endif
End

Subprog D_CCE1(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=1 : Gosub D_CCEX
End

Subprog AS_CCE1(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=1 : Gosub AS_CCEX
End

Subprog C_CCE1(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=1 : Gosub C_CCEX
End

Subprog D_CCE2(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=2 : Gosub D_CCEX
End

Subprog AS_CCE2(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=2 : Gosub AS_CCEX
End

Subprog C_CCE2(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=2 : Gosub C_CCEX
End

Subprog D_CCE3(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=3 : Gosub D_CCEX
End

Subprog AS_CCE3(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=3 : Gosub AS_CCEX
End

Subprog C_CCE3(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=3 : Gosub C_CCEX
End

Subprog D_CCE4(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=4 : Gosub D_CCEX
End

Subprog AS_CCE4(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=4 : Gosub AS_CCEX
End

Subprog C_CCE4(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=4 : Gosub C_CCEX
End

Subprog D_CCE5(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=5 : Gosub D_CCEX
End

Subprog AS_CCE5(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=5 : Gosub AS_CCEX
End

Subprog C_CCE5(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=5 : Gosub C_CCEX
End

Subprog D_CCE6(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=6 : Gosub D_CCEX
End

Subprog AS_CCE6(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=6 : Gosub AS_CCEX
End

Subprog C_CCE6(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=6 : Gosub C_CCEX
End

Subprog D_CCE7(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=7 : Gosub D_CCEX
End

Subprog AS_CCE7(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=7 : Gosub AS_CCEX
End

Subprog C_CCE7(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=7 : Gosub C_CCEX
End

Subprog D_CCE8(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=8 : Gosub D_CCEX
End

Subprog AS_CCE8(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=8 : Gosub AS_CCEX
End

Subprog C_CCE8(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=8 : Gosub C_CCEX
End

Subprog D_CCE9(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=9 : Gosub D_CCEX
End

Subprog AS_CCE9(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=9 : Gosub AS_CCEX
End

Subprog C_CCE9(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=9 : Gosub C_CCEX
End

Subprog D_CCE10(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=10 : Gosub D_CCEX
End

Subprog AS_CCE10(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=10 : Gosub AS_CCEX
End

Subprog C_CCE10(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=10 : Gosub C_CCEX
End

Subprog D_CCE11(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=11 : Gosub D_CCEX
End

Subprog AS_CCE11(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=11 : Gosub AS_CCEX
End

Subprog C_CCE11(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=11 : Gosub C_CCEX
End

Subprog D_CCE12(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=12 : Gosub D_CCEX
End

Subprog AS_CCE12(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=12 : Gosub AS_CCEX
End

Subprog C_CCE12(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=12 : Gosub C_CCEX
End

Subprog D_CCE13(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=13 : Gosub D_CCEX
End

Subprog AS_CCE13(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=13 : Gosub AS_CCEX
End

Subprog C_CCE13(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=13 : Gosub C_CCEX
End

Subprog D_CCE14(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=14 : Gosub D_CCEX
End

Subprog AS_CCE14(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=14 : Gosub AS_CCEX
End

Subprog C_CCE14(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=14 : Gosub C_CCEX
End

Subprog D_CCE15(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=15 : Gosub D_CCEX
End

Subprog AS_CCE15(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=15 : Gosub AS_CCEX
End

Subprog C_CCE15(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=15 : Gosub C_CCEX
End

Subprog D_CCE16(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=16 : Gosub D_CCEX
End

Subprog AS_CCE16(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=16 : Gosub AS_CCEX
End

Subprog C_CCE16(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=16 : Gosub C_CCEX
End

Subprog D_CCE17(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=17 : Gosub D_CCEX
End

Subprog AS_CCE17(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=17 : Gosub AS_CCEX
End

Subprog C_CCE17(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=17 : Gosub C_CCEX
End

Subprog D_CCE18(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=18 : Gosub D_CCEX
End

Subprog AS_CCE18(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=18 : Gosub AS_CCEX
End

Subprog C_CCE18(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=18 : Gosub C_CCEX
End

Subprog D_CCE19(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=19 : Gosub D_CCEX
End

Subprog AS_CCE19(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=19 : Gosub AS_CCEX
End

Subprog C_CCE19(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=19 : Gosub C_CCEX
End

Subprog D_CCE20(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=20 : Gosub D_CCEX
End

Subprog AS_CCE20(VALEUR)
Variable Char     VALEUR()
Local    Integer AXE : AXE=20 : Gosub AS_CCEX
End

Subprog C_CCE20(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=20 : Gosub C_CCEX
End

$D_CCEX
#------------------------------------#
# Initialisation commune aux 20 axes #
#------------------------------------#
If AXE>GNBDIE  Return : Endif
Call INIT_CCE(VALEUR,AXE,"PTD","[M:PTH1]LINACC",nolign-1) From TRTX3CPT
Return

$AS_CCEX
#----------------------------------#
# Avant saisie commune aux 20 axes #
#----------------------------------#
If GMODIF<>2  mkstat=2 : Return : Endif
Call SAIS_CCE(VALEUR,AXE,"[M:PTH1]LINACC","") From TRTX3CPT
# Issue 76502 - 2011-09-27 by VPO : on refait init pour cas sections précedentes
#car PREP_INIT_CCE déjà fait sur comptes
If !mkstat
   If VALEUR=""
      Call INIT_CCE(VALEUR,AXE,"PTD","[M:PTH1]LINACC",nolign-1) From TRTX3CPT
   Endif
Endif
Return

$C_CCEX
#-----------------------------#
# Contrôle commun aux 20 axes #
#-----------------------------#
Call CTRL_CCE(VALEUR,AXE,"[M:PTH1]LINACC",GFINRSP,[M:PTH0]RCPDAT) From TRTX3CPT
Return

Subprog AS_CPRCOE(VALEUR)
#--------------------------------#
# Avant saisie coeff d'approche  #
#--------------------------------#
Variable Decimal  VALEUR
Local Shortint NOL : NOL=nolign-1
# Issue 94186 - 2013-11-06 by MUARN : landed cost et sous traitance
# Issue 90597 - 2013-06-20 by MUARN : pas de modification en sous-traitance
# Issue 102827 - 2014-11-03 by MUARN : nom modifiable après création
If [M:PTH1]LINTYP(NOL)>1 | [M:PTH1]CREFLG(NOL)<>0
  mkstat=2 : End
Endif
#If [M:PTH1]INVQTYSTU(NOL)<>0  mkstat=2 : End : Endif
If [M:PTH1]INVQTYSTU(NOL)<>0
  If [F:POQ]POHNUM<>[M:PTH1]POHNUM(NOL) |
&    [F:POQ]POPLIN<>[M:PTH1]POPLIN(NOL) |
&    [F:POQ]POQSEQ<>[M:PTH1]POQSEQ(NOL)
    Read [POQ] POQ0=[M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat  Raz [F:POQ] : Endif
  Endif
  If [F:POQ]INVQTYPUU>[F:POQ]RCPQTYPUU  mkstat=2 : End : Endif
Endif
End

Subprog AS_CPR(VALEUR)
#-------------------------#
# Avant saisie prix ordre #
#-------------------------#
Variable Decimal VALEUR
Local Shortint NOL : NOL=nolign-1
Local Decimal  WPRIPUR
# Issue 90597 - 2013-06-20 by MUARN : pas de modification en sous-traitance
# Issue 102827 - 2014-11-03 by MUARN : nom modifiable après création
If [M:PTH1]LINTYP(NOL)=2 | [M:PTH1]CREFLG(NOL)<>0
  mkstat=2 : End
Endif
#If [M:PTH1]INVQTYSTU(NOL)<>0  mkstat=2 : End : Endif
If [M:PTH1]INVQTYSTU(NOL)<>0
  If [F:POQ]POHNUM<>[M:PTH1]POHNUM(NOL) |
&    [F:POQ]POPLIN<>[M:PTH1]POPLIN(NOL) |
&    [F:POQ]POQSEQ<>[M:PTH1]POQSEQ(NOL)
    Read [POQ] POQ0=[M:PTH1]POHNUM(NOL);[M:PTH1]POPLIN(NOL);[M:PTH1]POQSEQ(NOL)
    If fstat  Raz [F:POQ] : Endif
  Endif
  If [F:POQ]INVQTYPUU>[F:POQ]RCPQTYPUU  mkstat=2 : End : Endif
Endif
End

Subprog C_EECINCRAT(VALEUR)
#--------------#
# Controle CEE #
#--------------#
Variable Decimal  VALEUR
# Suppression de l'option + dans le masque
# Qui n'est pas traitée en import
If VALEUR < 0 : mkstat=2 : End : Endif
End

Subprog AS_TRSFAM(VALEUR)
#--------------------------------#
# Avant saisie famille mouvement #
#--------------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If [M:PTH0]BETFCY=2 | [M:PTH1]STOMGTCOD(NOL)<2        mkstat=2 : End : Endif
If [M:PTH1]CREFLG(NOL)<>0 & [M:PTH1]STOMGTCOD(NOL)>1  mkstat=2 : End : Endif
End

# Issue 71069 - 2013-08-23 by SR : PJT
#Subprog AS_PJT(VALEUR)
#-------------------------------#
# Avant saisie du code affaire  #
#-------------------------------#
#Variable Char    VALEUR()
#Local Shortint NOL : NOL=nolign-1
#If [M:PTH1]CREFLG(NOL)<>0 & [M:PTH1]STOMGTCOD(NOL)>1  mkstat=2 : End : Endif
#End

Subprog AS_VAT1(VALEUR)
#--------------------#
# Avant saisie taxe1 #
#--------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_VAT2(VALEUR)
#--------------------#
# Avant saisie taxe2 #
#--------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_VAT3(VALEUR)
#--------------------#
# Avant saisie taxe3 #
#--------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_TAXRCP(VALEUR)
#--------------------------------------#
# Avant saisie taxe provinciale entrée #
#--------------------------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_TAXISS(VALEUR)
#--------------------------------------#
# Avant saisie taxe provinciale sortie #
#--------------------------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_TAXOTH1(VALEUR)
#---------------------------------------#
# Avant saisie autre taxe provinciale 1 #
#---------------------------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

Subprog AS_TAXOTH2(VALEUR)
#---------------------------------------#
# Avant saisie autre taxe provinciale 2 #
#---------------------------------------#
Variable Char    VALEUR()
Gosub AS_VATX
End

$AS_VATX
#------------------------------#
# Avant saisie des codes taxes #
#------------------------------#
If [M:PTH1]POHNUM(nolign-1)<>"" | [M:PTH1]LINTYP(nolign-1)=2
  mkstat=2
Endif
Return

Subprog C_NBFAC
#-----------------------------------------------------#
# Contrôle sur numéro de ligne élément de facturation #
#-----------------------------------------------------#
Local Shortint NOL : NOL=nolign-1
#----- Interdiction de l'insertion et de la suppression sur réception soldée -----#
If find(status,65,73,82) & [M:PTH1]WCLEFLG=2  GMESSAGE=mess(248,194,1) : mkstat=2 : End : Endif
#----- Test suppression d'un élément non ajouté -----#
If status=65 & [M:PTH2]INVDTAFLG(NOL)=1  GMESSAGE=mess(136,194,1) : mkstat=2 : End : Endif
End

Subprog AVANT_NBFAC
#---------------------------------#
# Avant ligne élément facturation #
#---------------------------------#
Local   Shortint NOL : NOL=nolign-1
Local   Integer  AFF
#----- Si suppression ligne : Activation affichage dans MAJ_ELEMENT -----#
If status=65 | status=68 | status=83 AFF=1 : Endif
#----- Décrémentation des bases de taxe sans affichage -----#
Call MAJ_ELEMENT (NOL,AFF,-1) From SUBPTHD
If AFF=1 & (GPIHCALTAX=2 | (dim([M:PTH2]DISVATFLG)>0 & find(2,[M:PTH2]DISVATFLG(0..[M:PTH2]NBFAC-1))))
  Local Decimal WINVDTAAMT
  WINVDTAAMT=[M:PTH2]INVDTAAMT(NOL)
  Raz [M:PTH2]INVDTAAMT(NOL)
  For GPTH_INDTAX=1 To [M:PTH2]NBTAX
    Gosub CAL_TAXE_GLOB From SUBPTHD
  Next GPTH_INDTAX
  [M:PTH2]INVDTAAMT(NOL)=WINVDTAAMT
  If !GIMPORT Affzo [PTH2]10,15 : Endif
Endif
End

Subprog APRES_NBFAC
#---------------------------------#
# Après ligne élément facturation #
#---------------------------------#
Local    Shortint NOL : NOL=nolign-1
Local    Shortint I
#----- Si suppression ligne -----#
If status=65 | status=68 | status=83
  If !GIMPORT  Affzo [PTH2]10,15 : Endif
  End
Endif
#----- Si touche "Echap" ou autre statut "Abandon" -----#
If status=6 | status=7 | status=27 | status=28
  #If [M:PTH2]ACC1(NOL)="" & [M:PTH2]ACC2(NOL)="" & [M:PTH2]ACC3(NOL)=""
  #  Call INIT_COMPTES_INVDTA(NOL) From SUBPTHD
  #  Gosub AFFICH_ACC
  #Endif
  #----- Incrémentation bases taxe sans affichage et FIN -----#
  Call MAJ_ELEMENT (NOL,0,+1) From SUBPTHD : End
Endif
#----- Si no élément non renseigné, c'est fini ! -----#
If [M:PTH2]INVDTA(NOL)=0  Raz [M:PTH2]INVDTAFLG(NOL) : End : Endif
#----- Incrémentation des bases de taxe avec affichage -----#
Call MAJ_ELEMENT (NOL,2,+1) From SUBPTHD
#----- Recalcul taxe si besoin -----#
If GPIHCALTAX=2 | (dim([M:PTH2]DISVATFLG)>0 & find(2,[M:PTH2]DISVATFLG(0..[M:PTH2]NBFAC-1)))
  Local Shortint SAV_NBFAC : SAV_NBFAC=[M:PTH2]NBFAC
  If [M:PTH2]NBFAC<NOL+1  [M:PTH2]NBFAC=NOL+1 : Endif
  For GPTH_INDTAX=1 To [M:PTH2]NBTAX
    Gosub CAL_TAXE_GLOB From SUBPTHD
  Next GPTH_INDTAX
  [M:PTH2]NBFAC=SAV_NBFAC
  If !GIMPORT  Affzo [PTH2]10,15 : Endif
Endif
End

Subprog AS_INVDTA(VALEUR)
#---------------------------------------------#
# Avant saisie du No d'élément de facturation #
#---------------------------------------------#
Variable Decimal VALEUR
If [M:PTH2]INVDTA(nolign-1)<>0 & [M:PTH2]INVDTAFLG(nolign-1)=0
  [M:PTH2]INVDTAFLG(nolign-1)=2
Endif
If [M:PTH2]INVDTAFLG(nolign-1)<>0  mkstat=2 : Endif
End

Subprog C_INVDTA(VALEUR)
#----------------------------------------------------#
# Contrôle No d'élément déja présent dans le tableau #
#----------------------------------------------------#
Variable Decimal VALEUR
#-----
If find(VALEUR,[M:PTH2]INVDTA) & find(VALEUR,[M:PTH2]INVDTA)<>nolign
  GMESSAGE=mess(102,194,1) : mkstat=1
Endif
End

Subprog AM_INVDTA(VALEUR)
#------------------------------------------------#
# Après modif No d'élément : chargement libellé, #
#       valeur par défaut et indicateur d'ajout. #
#------------------------------------------------#
Variable Decimal VALEUR
Local    Shortint NOL : NOL=nolign-1
Local    Integer  STAT
#-----
If [F:PFI]DISVATFLG=2
  GMESSAGE=mess(412,194,1) : GERR=1 : mkstat=1 : End
Endif
#-----
Call LECTEXTRA(GBIDC3,"PFOOTINV","SHOAXX",num$([F:PFI]PFINUM),"") From ATEXTRA
[M:PTH2]INVDTALIB(NOL)=GBIDC3
If [F:PFI]AMTCOD=2
# Issue 85145 - 2012-10-15 by MUARN : en tunnel GCUR n a pas la même signification
#  Call CONVERT(GLOCALDEV,GCUR,GLOCALDEV,[M:PTH0]CHGTYP,datesyst,
#&              [F:PFI]DEFVAL,GBIDD3,STAT) From TRTDEV
  [M:PTH2]AMTCODLIB(NOL)=[M:PTH0]CUR

  Call CONVERT(GLOCALDEV,[M:PTH0]CUR,GLOCALDEV,[M:PTH0]CHGTYP,datesyst,
&              [F:PFI]DEFVAL,GBIDD3,STAT) From TRTDEV
  If [F:PFI]INCDCR=2 & GBIDD3>0 GBIDD3=-GBIDD3 : Endif
  [M:PTH2]INVDTAAMT(NOL)=GBIDD3
Endif
[M:PTH2]DEBCDT(NOL)=[F:PFI]INCDCR
[M:PTH2]CLCORD(NOL)=[F:PFI]CLCORD
[M:PTH2]CLCBAS(NOL)=[F:PFI]CLCBAS
[M:PTH2]INVDTAFLG(NOL)=2
Raz [M:PTH2]INVORDAMT(NOL),[M:PTH2]INVLINAMT(NOL),[M:PTH2]INVCPLAMT(NOL),
&   [M:PTH2]INVDTAVAT(NOL),[M:PTH2]DTAAMTTAX(NOL),[M:PTH2]DTADEDTAX(NOL)
If dim([M:PTH2]DISVATFLG)>0
  [M:PTH2]DISVATFLG(NOL)=[F:PFI]DISVATFLG
  If [F:PFI]DISVATFLG=2
    [M:PTH2]INVORDAMT(NOL)=[F:PFI]DEFVAL
  Endif
Endif
If dim([M:PTH2]DTADISBAS)>0  Raz [M:PTH2]DTADISBAS(NOL) : Endif
If [F:PFI]VATRUL=2
  Local Char WVAT(GLONVAT)
  If !clalev([F:TVC])  Local File TABVAC [TVC] : Endif
  Call RECHVATFOOT(2,[M:PTH0]BPSNUM,[F:PFI]PFINUM,"PTH2",WVAT) From TRTX3
  [M:PTH2]INVDTAVAT(NOL)=WVAT
Endif
[M:PTH2]INVLINFLG(NOL)=[F:PFI]DSPLIN
[M:PTH2]INVORDFLG(NOL)=[F:PFI]DACORD
[M:PTH2]DSP(NOL)      =[F:PFI]DSP
If !GIMPORT  Affzo [PTH2]INVDTALIB(NOL), DSP(NOL) : Endif
End

Subprog AS_INVDTAAMT(VALEUR)
#--------------------------------------------------#
# Avant saisie d'un montant élément de facturation #
#--------------------------------------------------#
Variable Decimal  VALEUR
If dim([M:PTH2]DISVATFLG)>0 & [M:PTH2]DISVATFLG(nolign-1)=2  mkstat=2 : Endif
End

Subprog AM_INVDTAAMT(VALEUR)
#------------------------------------------------------------#
# Après modif d'un montant élément de facturation (Mt saisi) #
#------------------------------------------------------------#
Variable Decimal  VALEUR
Local    Shortint NOL : NOL=nolign-1
If [M:PTH2]DEBCDT(NOL)=2
  If VALEUR>0  VALEUR=-VALEUR : Endif
Elsif VALEUR<0
  VALEUR=-VALEUR
Endif
Raz [M:PTH2]DTAAMTTAX(NOL), [M:PTH2]DTADEDTAX(NOL)
End

Subprog AS_INVORDAMT(VALEUR)
#---------------------------------------------------------------------#
# Avant saisie d'un montant élément de facturation (Mt pied commande) #
#---------------------------------------------------------------------#
Variable Decimal  VALEUR
#If dim([M:PTH2]DISVATFLG)>0 & [M:PTH2]DISVATFLG(nolign-1)=2
#  End : # Permettre la saisie du taux pour la remise sur taxe (cas particulier)
#Else
  mkstat=2
#Endif
End

Subprog AM_INVORDAMT(VALEUR)
#---------------------------------------------------------------------#
# Après modif d'un montant élément de facturation (Mt pied commande): #
#---------------------------------------------------------------------#
Variable Decimal  VALEUR
Local    Shortint NOL : NOL=nolign-1
#----- C'est une remise sur taxe (Settlement discount) -----#
If dim([M:PTH2]DISVATFLG)>0 & [M:PTH2]DISVATFLG(NOL)=2
  Raz [M:PTH2]DTADISBAS(NOL), [M:PTH2]DTAAMTTAX(NOL), [M:PTH2]DTADEDTAX(NOL) : End
Endif
#-----
If [M:PTH2]DEBCDT(NOL)=2
  If VALEUR>0  VALEUR=-VALEUR : Endif
Elsif VALEUR<0
  VALEUR=-VALEUR
Endif
End

Subprog AS_INVDTAVAT(VALEUR)
#---------------------------#
# Avant saisie du code taxe #
#---------------------------#
Variable Char    VALEUR()
Local    Shortint NOL : NOL=nolign-1
If VALEUR="" &
& ([M:PTH2]INVLINFLG(NOL)>1 | (dim([M:PTH2]DISVATFLG)>0 & [M:PTH2]DISVATFLG(NOL)=2))
  mkstat=2 : End
Endif
End

Subprog D_ACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub D_ACCX
End

Subprog AS_ACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub AS_ACCX
End

Subprog C_ACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub C_ACCX
End

Subprog AM_ACC1(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=1 : Gosub AM_ACCX
End

Subprog D_ACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub D_ACCX
End

Subprog AS_ACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub AS_ACCX
End

Subprog C_ACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub C_ACCX
End

Subprog AM_ACC2(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=2 : Gosub AM_ACCX
End

Subprog D_ACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub D_ACCX
End

Subprog AS_ACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub AS_ACCX
End

Subprog C_ACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub C_ACCX
End

Subprog AM_ACC3(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=3 : Gosub AM_ACCX
End

Subprog D_ACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub D_ACCX
End

Subprog AS_ACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub AS_ACCX
End

Subprog C_ACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub C_ACCX
End

Subprog AM_ACC4(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=4 : Gosub AM_ACCX
End

Subprog D_ACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub D_ACCX
End

Subprog AS_ACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub AS_ACCX
End

Subprog C_ACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub C_ACCX
End

Subprog AM_ACC5(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=5 : Gosub AM_ACCX
End

Subprog D_ACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub D_ACCX
End

Subprog AS_ACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub AS_ACCX
End

Subprog C_ACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub C_ACCX
End

Subprog AM_ACC6(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=6 : Gosub AM_ACCX
End

Subprog D_ACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub D_ACCX
End

Subprog AS_ACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub AS_ACCX
End

Subprog C_ACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub C_ACCX
End

Subprog AM_ACC7(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=7 : Gosub AM_ACCX
End

Subprog D_ACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub D_ACCX
End

Subprog AS_ACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub AS_ACCX
End

Subprog C_ACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub C_ACCX
End

Subprog AM_ACC8(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=8 : Gosub AM_ACCX
End

Subprog D_ACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub D_ACCX
End

Subprog AS_ACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub AS_ACCX
End

Subprog C_ACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub C_ACCX
End

Subprog AM_ACC9(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=9 : Gosub AM_ACCX
End

Subprog D_ACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub D_ACCX
End

Subprog AS_ACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub AS_ACCX
End

Subprog C_ACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub C_ACCX
End

Subprog AM_ACC10(VALEUR)
Variable Char    VALEUR()
Local    Integer PLAN : PLAN=10 : Gosub AM_ACCX
End

$D_ACCX
#---------------------------------------#
# Initialisation commune aux 10 comptes #
#---------------------------------------#
If PLAN>GNBCOA  Return : Endif
Local Shortint NOL : NOL=nolign-1
Call INIT_COMPTES_INVDTA(NOL) From SUBPTHD
Case PLAN
  When  1 : VALEUR=[M:PTH2]ACC1(NOL)
  When  2 : VALEUR=[M:PTH2]ACC2(NOL)
  When  3 : VALEUR=[M:PTH2]ACC3(NOL)
  When  4 : VALEUR=[M:PTH2]ACC4(NOL)
  When  5 : VALEUR=[M:PTH2]ACC5(NOL)
  When  6 : VALEUR=[M:PTH2]ACC6(NOL)
  When  7 : VALEUR=[M:PTH2]ACC7(NOL)
  When  8 : VALEUR=[M:PTH2]ACC8(NOL)
  When  9 : VALEUR=[M:PTH2]ACC9(NOL)
  When 10 : VALEUR=[M:PTH2]ACC10(NOL)
Endcase
Gosub AFFICH_ACC
Return

$AS_ACCX
#-------------------------------------#
# Avant saisie commune aux 10 comptes #
#-------------------------------------#
Call AVSAI_ACC(VALEUR,PLAN,"[M:PTH2]ACC") From TRTX3CPT
Return

$C_ACCX
#--------------------------------#
# Contrôle commun aux 10 comptes #
#--------------------------------#
Local    Shortint NOL : NOL=nolign-1
#-----
Call CTRL_ACC(VALEUR,PLAN,GFINRSP,[M:PTH0]RCPDAT,[M:PTH0]CUR,"[M:PTH2]ACC") From TRTX3CPT
#-----
Return

$AM_ACCX
#------------------------------------#
# Après modif commune aux 10 comptes #
#------------------------------------#
Local    Shortint I
Local    Shortint NOL : NOL=nolign-1
#-----
# Issue 106746 - 2015-04-02 by SR :
If GREP="C"
  For I=PLAN+1 To dim(GCOA)
      If I<=GNBCOA
         Assign "[M:PTH2]ACC"+num$(I)+"(NOL)" With ""
      Else
         Break
      Endif
  Next
Endif
# End issue 106746
Call APMOD_ACC(VALEUR,PLAN,"[M:PTH2]ACC") From TRTX3CPT
#-----
If [F:GAC]COA<>GCOA(PLAN) | [F:GAC]ACC<>VALEUR
   Read [GAC] GAC0=GCOA(PLAN);VALEUR : If fstat Raz [F:GAC] : Endif
Endif
Assign "[M:PTH2]ACC"+num$(PLAN)+"(NOL)" With VALEUR
GBIDI2=1 : Gosub PREP_INIT_PFICCE From SUBPTHD
Return

Subprog AS_DSP(VALEUR)
#---------------------------------------#
# Avant saisie de la clé de répartition #
#---------------------------------------#
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
Local Char     WACC(GLONGAC)
Call RECH_ACC(2,"[M:PTH2]ACC",NOL,WACC) From TRTX3CPT
If WACC=""  mkstat=2 : End : Endif
End

Subprog AM_DSP(VALEUR)
#---------------------------------------------#
# Après modification de la clé de répartition #
#---------------------------------------------#
Variable Char    VALEUR()
Local Shortint I
Local Shortint NOL : NOL=nolign-1
[M:PTH2]DSP(NOL)=VALEUR
GBIDI2=1 : Gosub PREP_INIT_PFICCE From SUBPTHD
End

Subprog AS_LINCAT(VALEUR)
#--------------------------------------------------#
# Champ accessible uniquement en réception directe #
#--------------------------------------------------#
Variable Integer VALEUR
If [M:PTH1]POHNUM(nolign-1)<>"" | [M:PTH1]SDHNUM(nolign-1)<>""
  mkstat=2 : End
Endif
End

Subprog AM_LINCAT(VALEUR)
#--------------------------------------------------#
# Champ accessible uniquement en réception directe #
# Pas de valorisation si LINCAT=2                  #
#--------------------------------------------------#
Variable Integer VALEUR
Local Shortint NOL : NOL=nolign-1
#----- Remise à zéro tarif ou initialisation tarif -----#
If [M:PTH1]POHNUM(NOL)="" & [M:PTH1]SDHNUM(NOL)=""
  If VALEUR=2
    #----- Raz éléments ligne tarif -----#
    [M:PTH1]LINCAT(NOL)=VALEUR
    Call REAJUST_TARIF("PTH1",NOL,[M:PTH1]UOM(NOL),[M:PTH1]UOM(NOL),1,1) From TRTACHPRI1
  Elsif [M:PTH1]GROPRI(NOL)=0 & [M:PTH1]NETPRI(NOL)=0
    #----- Recherche tarif si ligne valorisée à zéro -----#
    Call INI_TARIF(NOL,"LINCAT") From SUBPTHB
  Endif
Endif
#-----
End

Subprog D_PFICCE1(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=1 : Gosub D_PFICCEX
End

Subprog AS_PFICCE1(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=1 : Gosub AS_PFICCEX
End

Subprog C_PFICCE1(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=1 : Gosub C_PFICCEX
End

Subprog D_PFICCE2(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=2 : Gosub D_PFICCEX
End

Subprog AS_PFICCE2(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=2 : Gosub AS_PFICCEX
End

Subprog C_PFICCE2(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=2 : Gosub C_PFICCEX
End

Subprog D_PFICCE3(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=3 : Gosub D_PFICCEX
End

Subprog AS_PFICCE3(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=3 : Gosub AS_PFICCEX
End

Subprog C_PFICCE3(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=3 : Gosub C_PFICCEX
End

Subprog D_PFICCE4(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=4 : Gosub D_PFICCEX
End

Subprog AS_PFICCE4(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=4 : Gosub AS_PFICCEX
End

Subprog C_PFICCE4(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=4 : Gosub C_PFICCEX
End

Subprog D_PFICCE5(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=5 : Gosub D_PFICCEX
End

Subprog AS_PFICCE5(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=5 : Gosub AS_PFICCEX
End

Subprog C_PFICCE5(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=5 : Gosub C_PFICCEX
End

Subprog D_PFICCE6(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=6 : Gosub D_PFICCEX
End

Subprog AS_PFICCE6(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=6 : Gosub AS_PFICCEX
End

Subprog C_PFICCE6(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=6 : Gosub C_PFICCEX
End

Subprog D_PFICCE7(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=7 : Gosub D_PFICCEX
End

Subprog AS_PFICCE7(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=7 : Gosub AS_PFICCEX
End

Subprog C_PFICCE7(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=7 : Gosub C_PFICCEX
End

Subprog D_PFICCE8(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=8 : Gosub D_PFICCEX
End

Subprog AS_PFICCE8(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=8 : Gosub AS_PFICCEX
End

Subprog C_PFICCE8(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=8 : Gosub C_PFICCEX
End

Subprog D_PFICCE9(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=9 : Gosub D_PFICCEX
End

Subprog AS_PFICCE9(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=9 : Gosub AS_PFICCEX
End

Subprog C_PFICCE9(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=9 : Gosub C_PFICCEX
End

Subprog D_PFICCE10(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=10 : Gosub D_PFICCEX
End

Subprog AS_PFICCE10(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=10 : Gosub AS_PFICCEX
End

Subprog C_PFICCE10(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=10 : Gosub C_PFICCEX
End

Subprog D_PFICCE11(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=11 : Gosub D_PFICCEX
End

Subprog AS_PFICCE11(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=11 : Gosub AS_PFICCEX
End

Subprog C_PFICCE11(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=11 : Gosub C_PFICCEX
End

Subprog D_PFICCE12(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=12 : Gosub D_PFICCEX
End

Subprog AS_PFICCE12(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=12 : Gosub AS_PFICCEX
End

Subprog C_PFICCE12(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=12 : Gosub C_PFICCEX
End

Subprog D_PFICCE13(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=13 : Gosub D_PFICCEX
End

Subprog AS_PFICCE13(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=13 : Gosub AS_PFICCEX
End

Subprog C_PFICCE13(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=13 : Gosub C_PFICCEX
End

Subprog D_PFICCE14(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=14 : Gosub D_PFICCEX
End

Subprog AS_PFICCE14(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=14 : Gosub AS_PFICCEX
End

Subprog C_PFICCE14(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=14 : Gosub C_PFICCEX
End

Subprog D_PFICCE15(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=15 : Gosub D_PFICCEX
End

Subprog AS_PFICCE15(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=15 : Gosub AS_PFICCEX
End

Subprog C_PFICCE15(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=15 : Gosub C_PFICCEX
End

Subprog D_PFICCE16(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=16 : Gosub D_PFICCEX
End

Subprog AS_PFICCE16(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=16 : Gosub AS_PFICCEX
End

Subprog C_PFICCE16(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=16 : Gosub C_PFICCEX
End

Subprog D_PFICCE17(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=17 : Gosub D_PFICCEX
End

Subprog AS_PFICCE17(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=17 : Gosub AS_PFICCEX
End

Subprog C_PFICCE17(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=17 : Gosub C_PFICCEX
End

Subprog D_PFICCE18(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=18 : Gosub D_PFICCEX
End

Subprog AS_PFICCE18(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=18 : Gosub AS_PFICCEX
End

Subprog C_PFICCE18(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=18 : Gosub C_PFICCEX
End

Subprog D_PFICCE19(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=19 : Gosub D_PFICCEX
End

Subprog AS_PFICCE19(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=19 : Gosub AS_PFICCEX
End

Subprog C_PFICCE19(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=19 : Gosub C_PFICCEX
End

Subprog D_PFICCE20(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=20 : Gosub D_PFICCEX
End

Subprog AS_PFICCE20(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=20 : Gosub AS_PFICCEX
End

Subprog C_PFICCE20(VALEUR)
Variable Char    VALEUR()
Local    Integer AXE : AXE=20 : Gosub C_PFICCEX
End

$D_PFICCEX
#------------------------------------#
# Initialisation commune aux 20 axes #
#------------------------------------#
If AXE>GNBDIE  Return : Endif
If [M:PTH2]DSP(nolign-1)<>""  VALEUR="" : Return : Endif
Call INIT_CCE(VALEUR,AXE,"PTV","[M:PTH2]ACC",nolign-1) From TRTX3CPT
Return

$AS_PFICCEX
#----------------------------------#
# Avant saisie commune aux 20 axes #
#----------------------------------#
Call SAIS_CCE(VALEUR,AXE,"[M:PTH2]ACC","[M:PTH2]DSP") From TRTX3CPT
Return

$C_PFICCEX
#-----------------------------#
# Contrôle commun aux 20 axes #
#-----------------------------#
Call CTRL_PFICCE(VALEUR,AXE,"[M:PTH2]ACC",GFINRSP,[M:PTH0]RCPDAT) From TRTX3CPT
Return

Subprog AS_AMTTAX(VALEUR)
#---------------------------#
# Avant saisie montant taxe #
#---------------------------#
Variable Decimal  VALEUR
If [M:PTH1]NBLIG=0  mkstat=2 : Endif
End

Subprog AM_AMTTAX(VALEUR)
#--------------------------#
# Après modif montant taxe #
#--------------------------#
Variable Decimal  VALEUR
Local    Shortint NOL : NOL=nolign-1
#----- Réajustement de la partie déductible -----#
If [M:PTH2]DEDTAXCOE(NOL)=0 & [M:PTH2]AMTTAX(NOL)<>0
   [M:PTH2]DEDTAXCOE(NOL)=[M:PTH2]DEDTAX(NOL)/[M:PTH2]AMTTAX(NOL) : Endif
[M:PTH2]DEDTAX(NOL)=arr(VALEUR*[M:PTH2]DEDTAXCOE(NOL),GPTH_RND)
#----- Calcul et affichage total des taxes -----#
[M:PTH2]AMTTAX(NOL)=VALEUR
If !GIMPORT  Affzo [PTH2]15 : Endif
#----- Réajustement des montants de taxe sur éléments et lignes facture -----#
Call MAJ_TAXE (NOL) From SUBPTHD : If !GIMPORT  Affzo [PTH2]10 : Endif
End

Subprog AV_TOTAMTNOT(VALEUR)
#---------------------#
# Avant zone total HT #
#---------------------#
Variable Decimal VALEUR
VALEUR=sum([M:PTH2]INVDTAAMT)+[M:PTH2]TOTLINAMT
End

Subprog AV_TOTTAXAMT(VALEUR)
#------------------------#
# Avant zone total taxes #
#------------------------#
Variable Decimal VALEUR
If [M:PTH0]VACTYP<>4
  VALEUR=sum([M:PTH2]AMTTAX)
Else
  VALEUR=0
Endif
End

Subprog AV_TOTAMTATI(VALEUR)
#----------------------#
# Avant zone total TTC #
#----------------------#
Variable Decimal VALEUR
If [M:PTH0]VACTYP<>4
  VALEUR=sum([M:PTH2]INVDTAAMT)+[M:PTH2]TOTLINAMT+sum([M:PTH2]AMTTAX)
Else
  VALEUR=sum([M:PTH2]INVDTAAMT)+[M:PTH2]TOTLINAMT
Endif
End

#----------------------------------------------------------------------------#
# Vérifications - si des qés sont allouées ou des numéros de série sortis    #
#               - si le stock est là                                         #
# -------------------------------------------------------------------------- #
# En entrée :                                                                #
#  WVERIF   : 1 = Contrôle une seule ligne réception depuis C_NBLIG          #
#             2 = Contrôle une seule ligne réception depuis VALLIG -1        #
#             3 = Contrôle toutes les lignes d'une réception depuis VERF_ANU #
# En sortie :                                                                #
#  GMESSAGE : Renseigné si erreur autrement vide                             #
#----------------------------------------------------------------------------#
$VERIF_QTEALL
#----- Déclaration des variables nécessaires au calcul -----#
If dim(WNBR_STOCOU)<0   Local Shortint WNBR_STOCOU      : Endif
If dim(WTAB_STOCOU)<0   Local Decimal  WTAB_STOCOU(100) : Endif
If dim(WTAB_STOQTY)<0   Local Decimal  WTAB_STOQTY(100) : Endif
If dim(WCUM_STJQTYA)<0  Local Decimal  WCUM_STJQTYA     : Endif
If dim(WCUM_STJQTYQ)<0  Local Decimal  WCUM_STJQTYQ     : Endif
If dim(WCUM_STJQTYR)<0  Local Decimal  WCUM_STJQTYR     : Endif
If dim(WCUM_QTYSTUA)<0  Local Decimal  WCUM_QTYSTUA     : Endif
If dim(WCUM_QTYSTUQ)<0  Local Decimal  WCUM_QTYSTUQ     : Endif
If dim(WCUM_QTYSTUR)<0  Local Decimal  WCUM_QTYSTUR     : Endif
If dim(WCUM_ALLQTYA)<0  Local Decimal  WCUM_ALLQTYA     : Endif
If dim(WCUM_ALLQTYQ)<0  Local Decimal  WCUM_ALLQTYQ     : Endif
If dim(WCUM_ALLQTYR)<0  Local Decimal  WCUM_ALLQTYR     : Endif
If dim(WSTOCOU)<0       Local Decimal  WSTOCOU          : Endif
If dim(WSTUDIS)<0       Local Decimal  WSTUDIS          : Endif
If dim(WSTUDISTOT)<0    Local Decimal  WSTUDISTOT       : Endif
If dim(WPLF)<0          Local Libelle  WPLF             : Endif
If dim(WSCO)<0          Local Libelle  WSCO             : Endif
If dim(WBPR)<0          Local Libelle  WBPR             : Endif
If dim(WLOCTYP)<0       Local Integer  WLOCTYP          : Endif
Local Integer WSTA
Local Decimal WDIS, WDISA, WDISQ, WDISR
Local Decimal WCUM, WGLOALL

#-----
Raz GMESSAGE
If WVERIF=1
   #----- Depuis le C_NBLIG suppression d'une ligne, NOL renseigné -----#
   If [F:PTD]PTHNUM<>[M:PTH0]PTHNUM | [F:PTD]PTDLIN<>[M:PTH1]PTDLIN(NOL)
     Read [PTD] PTD0=[M:PTH0]PTHNUM;[M:PTH1]PTDLIN(NOL)
     If fstat  Raz [F:PTD] : Endif
   Endif
   If [F:PTD]PTHNUM<>""  Gosub VERIF_LINQTEALL : Endif
Elsif WVERIF=2
  #----- Depuis VALLIG -1 suppression d'une ligne [F:PTD] renseigné -----#
  Gosub VERIF_LINQTEALL
Else
  #----- Depuis VERF_ANU suppression complète de la réception -----#
  For [PTD] PTD0 Where PTHNUM=[M:PTH0]PTHNUM
    Gosub VERIF_LINQTEALL
    If GMESSAGE<>""  Break : Endif
  Next
Endif
Return

#--------------------------#
# Vérification d'une ligne #
#--------------------------#
$VERIF_LINQTEALL
#--- Bug 72695
Local Char WQLYCTLDEM(GLONVCR) : Raz WQLYCTLDEM

#----- Lecture article, catégorie, cumuls article-site si nécessaire -----#
If [F:ITM]ITMREF<>[F:PTD]ITMREF
  Read [ITM] ITM0=[F:PTD]ITMREF : If fstat  Raz [F:ITM] : Endif
Endif
If [F:PTD]STOMGTCOD<2  Return : Endif : # Si article non géré en stock, c'est fini !
If [F:ITG]STOFCY<>[M:PTH0]PRHFCY | [F:ITG]TCLCOD<>[F:ITM]TCLCOD
  Read [ITG] ITG0=[M:PTH0]PRHFCY;[F:ITM]TCLCOD
  If fstat
    Read [ITG] ITG1=[F:ITM]TCLCOD;"" : If fstat  Raz [F:ITG] : Endif
  Endif
Endif
If [F:ITG]TCLCOD=""  Return : Endif : # Si catégorie article non trouvée, c'est fini !
If [F:ITV]ITMREF<>[F:PTD]ITMREF | [F:ITV]STOFCY<>[M:PTH0]PRHFCY
  Read [ITV] ITV0=[F:PTD]ITMREF;[M:PTH0]PRHFCY : If fstat  Raz [F:ITV] : Endif
Endif
#-----
Raz WTAB_STOCOU,    WNBR_STOCOU,    WTAB_STOQTY
Raz WCUM_STJQTYA,   WCUM_QTYSTUA,   WCUM_ALLQTYA
Raz WCUM_STJQTYQ,   WCUM_QTYSTUQ,   WCUM_ALLQTYQ
Raz WCUM_STJQTYR,   WCUM_QTYSTUR,   WCUM_ALLQTYR
Raz WPLF, WSCO, WBPR, WLOCTYP
Raz WSTUDIS, WSTUDISTOT
#-----
For [STJ] STJ1 Where STOFCY=[F:PTD]PRHFCY
&                  & VCRTYP=6
&                  & VCRNUM=[F:PTD]PTHNUM
&                  & VCRLIN=[F:PTD]PTDLIN
&                  & REGFLG<>2
&                  & TRSTYP<>29                : #--- Issue 115206
  If [F:STJ]IPTDAT<>[M:PTH0]RCPDAT
    GMESSAGE=mess(392,194,1)-"("+num$([F:STJ]IPTDAT)-"-->"-num$([M:PTH0]RCPDAT)+")"
    GMESSAGE+="\"+mess(54,123,1)+"!" : Break
  Endif
  #--- Bug 72695
  If WQLYCTLDEM="" WQLYCTLDEM=[F:STJ]QLYCTLDEM Endif
  Case left$([F:STJ]STA,1)
    When "A" : WCUM_STJQTYA+=[F:STJ]ACTQTY
    When "Q" : WCUM_STJQTYQ+=[F:STJ]ACTQTY
    When "R" : WCUM_STJQTYR+=[F:STJ]ACTQTY
  Endcase
  Call CLESTO([F:STJ]STOFCY,[F:STJ]ITMREF,[F:STJ]LOT,[F:STJ]SLO,[F:STJ]BPSLOT,
&             [F:STJ]PALNUM,[F:STJ]CTRNUM,[F:STJ]STA,[F:STJ]LOC,[F:STJ]PCU,
&             [F:STJ]PCUSTUCOE,[F:STJ]SERNUM,[F:STJ]QLYCTLDEM,[F:STJ]OWNER,
&             [F:STJ]STOFLD1,[F:STJ]STOFLD2,[L]WSTOCOU) From STKLIB
  If WSTOCOU<>0
    If WNBR_STOCOU=0
      WTAB_STOCOU(0)=WSTOCOU
      WTAB_STOQTY(0)=[F:STJ]QTYSTU
      WNBR_STOCOU+=1
    Else I=find(WSTOCOU,WTAB_STOCOU(0..WNBR_STOCOU-1))
      If I=0
        WTAB_STOCOU(WNBR_STOCOU)=WSTOCOU
        WTAB_STOQTY(WNBR_STOCOU)=[F:STJ]QTYSTU
        WNBR_STOCOU+=1
      Else
        WTAB_STOQTY(I-1)+=[F:STJ]QTYSTU
      Endif
    Endif
    If WNBR_STOCOU>=dim(WTAB_STOCOU)-1  Break : Endif : # Par sécurité, ne devrait jamais arriver !
  Endif
Next
#--- Bug 72695
If WQLYCTLDEM<>"" & GMESSAGE=""
   #-- Des mouvements ont-ils eu lieu ?
   For [STJ]STJ1  Where STOFCY=[F:PTD]PRHFCY & VCRTYP=28 & VCRNUM=WQLYCTLDEM
&                     & VCRNUMORI=[F:PTD]PTHNUM & VCRLINORI=[F:PTD]PTDLIN & REGFLG<>2
       # Contrôle qualité partiellement réalisé ou terminé
       GMESSAGE =[F:PTD]PTHNUM-[F:PTD]BPSNUM-[F:PTD]ITMREF-": "
       GMESSAGE+=mess(54,123,1)-"\"+mess(316,184,1)
       Break
   Next
Endif
#---
If GMESSAGE<>"" : Return : Endif
For I=0 To WNBR_STOCOU-1
  Read [STO] STO0=[F:PTD]PRHFCY;WTAB_STOCOU(I)
  If !fstat
    #----- Disponible sur la ligne de stock
    Call STODIS("[F:STO]","[F:ITM]","",GBIDD1,WSTUDIS,GBIDD3) From STKLIB
    If WTAB_STOQTY(I)>WSTUDIS
       Gosub CHARG_ERR2 : Break
    Endif
    #-----
    Case [F:STO]LOCCAT
      When  2  : WPLF=1  : # stock à quai
      When  3  : WBPR=1  : # stock chez client
      When  4  : WSCO=1  : # stock chez sous-traitance
    Endcase
  Endif
Next I
If GMESSAGE<>"" : Return : Endif
#----- Contrôle stock en global en fonction statut et emplacement -----#
If WPLF=1  WLOCTYP+=1 : Endif
If WBPR=1  WLOCTYP+=2 : Endif
If WSCO=1  WLOCTYP+=4 : Endif
#If WLOCTYP=0 WLOCTYP=1 Endif    : # Ajout GA 05/2008 pour test sinon impossible supprimer une rcp
If WCUM_STJQTYA>0 WSTA+=1 Endif
If WCUM_STJQTYQ>0 WSTA+=2 Endif
If WCUM_STJQTYR>0 WSTA+=4 Endif
If dim([F:PTD]LINCAT)>0 & find([F:PTD]LINCAT,2,3)
# Réception pour sous-traitance - GA 08/2006
# [M:PTH0]SALFCY identifie le site propriétaire du stock LOWN
#---Issue 94160 by TS
  #Call STODISMOD("",WLOCTYP,WSTA,[M:PT0]SALFCY,WDISA,WDISQ,WDISR,WGLOALL) From STKLIB
  Call STODISMOD("",WLOCTYP,WSTA,[F:PTD]LINSTOFCY,WDISA,WDISQ,WDISR,WGLOALL) From STKLIB
#---
Else
  Call STODISMOD("",WLOCTYP,WSTA,"",WDISA,WDISQ,WDISR,WGLOALL) From STKLIB
Endif
#----- Contrôle par statut -----#
If (WCUM_STJQTYA<>0 & WCUM_STJQTYA>WDISA) |
&  (WCUM_STJQTYQ<>0 & WCUM_STJQTYQ>WDISQ) |
&  (WCUM_STJQTYR<>0 & WCUM_STJQTYR>WDISR)
  Gosub CHARG_ERR2 : Return
Endif
#----- Contrôle avec prise en compte alloué global -----#
If WGLOALL<>0
  If [F:ITG]GLOAAAFLG=2
     WDIS+=WDISA
     WCUM+=WCUM_STJQTYA
  Endif
  If [F:ITG]GLOQQQFLG=2
     WDIS+=WDISQ
     WCUM+=WCUM_STJQTYQ
  Endif
  If [F:ITG]GLORRRFLG=2
     WDIS+=WDISR
     WCUM+=WCUM_STJQTYR
  Endif
  If WCUM > WDIS-WGLOALL
    Gosub CHARG_ERR2 : Return
  Endif
Endif
Return

#-----------------------------------------------------------------#
# Ligne réception allouée.\Modification ou suppression impossible #
#-----------------------------------------------------------------#
$CHARG_ERR1
GMESSAGE=[F:PTD]PTHNUM-[F:PTD]BPSNUM-[F:PTD]ITMREF-mess(208,194,1)
Return

#----------------------------------------------------------#
# Stock disponible insuffisant : suppression  impossible ! #
#----------------------------------------------------------#
$CHARG_ERR2
GMESSAGE=[F:PTD]PTHNUM-[F:PTD]BPSNUM-[F:PTD]ITMREF-mess(817,196,1)
Return

#--------------------------------------#
# Traitement du champ "BL fournisseur" #
#--------------------------------------#
$TRT_BPSNDE
If dim(SAV_STATUS)<1 Local Integer SAV_STATUS       : Endif
If dim(I)<1          Local Integer I                : Endif
If dim(WSDHNUM)<1    Local Char    WSDHNUM(GLONSDH) : Endif
#-----
SAV_STATUS=status
Raz WSDHNUM
If [M:PTH0]BETFCY=2
  For I=0 To [M:PTH1]NBLIG-1
    If [M:PTH1]SDHNUM(I)<>""  WSDHNUM=[M:PTH1]SDHNUM(I) : Break : Endif
  Next I
Endif
If WSDHNUM<>"" & !sigma(I=0,[M:PTH1]NBLIG-1,[M:PTH1]SDHNUM(I)<>WSDHNUM)
  If GREP="" : # Appel depuis l'action LIENS
    If !GIMPORT & [M:PTH0]BPSNDE<>""
      Diszo [PTH0]BPSNDE, NDEDAT
      If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
        Diszo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR
      Endif
    Endif
  Else       : # Appel depuis APRES_NBLIG ou DEPICK_LIV
    [M:PTH0]BPSNDE=WSDHNUM
    #----- Numérotation Argentine -----#
    If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
      If len(WSDHNUM)>14
        [M:PTH1]TYPVCR=mid$(WSDHNUM,len(WSDHNUM)-14,2)
        [M:PTH1]CLSVCR=mid$(WSDHNUM,len(WSDHNUM)-12,1)
        [M:PTH1]SCUVCR=mid$(WSDHNUM,len(WSDHNUM)-11,4)
        [M:PTH1]SEQVCR=mid$(WSDHNUM,len(WSDHNUM)-7,8)
      Else
        Raz [M:PTH1]TYPVCR, [M:PTH1]CLSVCR
        Raz [M:PTH1]SCUVCR, [M:PTH1]SEQVCR
      Endif
    Endif
    #-----
    If [F:SDH]SDHNUM<>WSDHNUM
      Read [SDH] SDH0=WSDHNUM : If fstat  Raz [F:SDH] : Endif
    Endif
    [M:PTH0]NDEDAT=[F:SDH]DLVDAT
    If !GIMPORT
      Affzo [PTH0]BPSNDE, NDEDAT : Diszo [PTH0]BPSNDE, NDEDAT
      If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
        Affzo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR
        Diszo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR
      Endif
    Endif
  Endif
Else
  If GREP<>"" & [M:PTH0]BETFCY=2
    #MAE, le 01/08/08, BPSNDE2 sur PTH0 et pas sur PTH1
    #If [M:PTH1]NBLIG=0  Raz [M:PTH1]BPSNDE2 : Endif
    If [M:PTH1]NBLIG=0  Raz [M:PTH0]BPSNDE2 : Endif
    If [M:PTH0]BPSNDE2<>""
      [M:PTH0]BPSNDE=[M:PTH0]BPSNDE2
      #----- Numérotation Argentine -----#
      If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
        If len([M:PTH0]BPSNDE2)>14
          [M:PTH1]TYPVCR=mid$([M:PTH0]BPSNDE2,len([M:PTH0]BPSNDE2)-14,2)
          [M:PTH1]CLSVCR=mid$([M:PTH0]BPSNDE2,len([M:PTH0]BPSNDE2)-12,1)
          [M:PTH1]SCUVCR=mid$([M:PTH0]BPSNDE2,len([M:PTH0]BPSNDE2)-11,4)
          [M:PTH1]SEQVCR=mid$([M:PTH0]BPSNDE2,len([M:PTH0]BPSNDE2)-7,8)
        Else
          Raz [M:PTH1]TYPVCR, [M:PTH1]CLSVCR
          Raz [M:PTH1]SCUVCR, [M:PTH1]SEQVCR
        Endif
      Endif
      #-----
    Else
      Raz [M:PTH0]BPSNDE
    Endif
    If [M:PTH0]NDEDAT2<>[0/0/0]
      [M:PTH0]NDEDAT=[M:PTH0]NDEDAT2
    Else
      [M:PTH0]NDEDAT=date$
    Endif
    If !GIMPORT
      Affzo [PTH0]BPSNDE, NDEDAT
      If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
        Affzo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR
      Endif
    Endif
  Endif
  If !GIMPORT
    Actzo [PTH0]BPSNDE, NDEDAT
    If GLOCARGNUM & dim([M:PTH1]TYPVCR)>0
      Actzo [PTH1]TYPVCR, CLSVCR, SCUVCR, SEQVCR
      If [M:PTH1]TYPVCR+[M:PTH1]CLSVCR+[M:PTH1]SCUVCR+[M:PTH1]SEQVCR<>""
        Diszo [PTH0]BPSNDE
      Endif
    Endif
  Endif
Endif
status=SAV_STATUS
Return

#----------------------------------------------------#
# Màj totaux poids brut et net de l'écran complément #
# -------------------------------------------------- #
# NOL    = Numéro de la ligne en cours               #
# SENS   = Sens de la mise à jour (+1 ou -1)         #
# GBIDD1 = Coefficient de conversion unités de poids #
# GBIDD2 = Total poids ligne de la réception         #
#----------------------------------------------------#
$MAJ_TOTWEI
If [M:PTH1]ITMREF(NOL)="" | [M:PTH1]LINTYP(NOL)>2  Return : Endif

# Issue 84130 - 2013-03-12 by MUARN : landed cost poids et volume modifiable à la ligne
If [M:PTHC]VOU=""  [M:PTHC]VOU=[M:PTH1]LINVOU(NOL) : Endif
If [M:PTHC]WEU=""  [M:PTHC]WEU=[M:PTH1]LINWEU(NOL) : Endif
If [M:PTH1]LINWEU(NOL) = [M:PTHC]WEU
  [M:PTHC]TOTGROWEI+=[M:PTH1]QTYWEU(NOL)*SENS
  [M:PTHC]TOTNETWEI+=[M:PTH1]QTYWEU(NOL)*SENS
Else
  Local Decimal W_QTYWEU
  Call PCAL_QTY([M:PTH1]QTYWEU(NOL), [M:PTH1]LINWEU(NOL), W_QTYWEU, [M:PTHC]WEU,
&                   [M:PTH1]ITMREF(NOL), [M:PTH0]BPSNUM, 1,GBIDD2) From TRTACHQTE1
  [M:PTHC]TOTGROWEI+=W_QTYWEU*SENS
  [M:PTHC]TOTNETWEI+=W_QTYWEU*SENS
Endif
If [M:PTH1]LINVOU(NOL) = [M:PTHC]VOU
  [M:PTHC]TOTVOL+=[M:PTH1]QTYVOU(NOL)*SENS
Else
  Local Decimal W_QTYVOU
  Call PCAL_QTY([M:PTH1]QTYVOU(NOL), [M:PTH1]LINVOU(NOL), W_QTYVOU, [M:PTHC]VOU,
&                   [M:PTH1]ITMREF(NOL), [M:PTH0]BPSNUM, 1,GBIDD2) From TRTACHQTE1
  [M:PTHC]TOTVOL+=W_QTYVOU*SENS
Endif

Return

$AFFICH_LINACC
#------------------------------------------------#
# Affichage des comptes de la ligne de réception #
#------------------------------------------------#
If dim(I)<1  Local Integer I : Endif
For I=1 To GNBCOA
  Case I
    When  1 : Affzo [PTH1]LINACC1(NOL)
    When  2 : Affzo [PTH1]LINACC2(NOL)
    When  3 : Affzo [PTH1]LINACC3(NOL)
    When  4 : Affzo [PTH1]LINACC4(NOL)
    When  5 : Affzo [PTH1]LINACC5(NOL)
    When  6 : Affzo [PTH1]LINACC6(NOL)
    When  7 : Affzo [PTH1]LINACC7(NOL)
    When  8 : Affzo [PTH1]LINACC8(NOL)
    When  9 : Affzo [PTH1]LINACC9(NOL)
    When 10 : Affzo [PTH1]LINACC10(NOL)
  Endcase
Next I
Return

$AFFICH_CCE
#--------------------------------------------------------#
# Affichage des sections analytiques de la ligne facture #
#--------------------------------------------------------#
If dim(I)<1  Local Integer I : Endif
For I=1 To GNBDIE
  Case I
    When  1 : Affzo [PTH1]CCE1 (NOL)
    When  2 : Affzo [PTH1]CCE2 (NOL)
    When  3 : Affzo [PTH1]CCE3 (NOL)
    When  4 : Affzo [PTH1]CCE4 (NOL)
    When  5 : Affzo [PTH1]CCE5 (NOL)
    When  6 : Affzo [PTH1]CCE6 (NOL)
    When  7 : Affzo [PTH1]CCE7 (NOL)
    When  8 : Affzo [PTH1]CCE8 (NOL)
    When  9 : Affzo [PTH1]CCE9 (NOL)
    When 10 : Affzo [PTH1]CCE10(NOL)
    When 11 : Affzo [PTH1]CCE11(NOL)
    When 12 : Affzo [PTH1]CCE12(NOL)
    When 13 : Affzo [PTH1]CCE13(NOL)
    When 14 : Affzo [PTH1]CCE14(NOL)
    When 15 : Affzo [PTH1]CCE16(NOL)
    When 16 : Affzo [PTH1]CCE17(NOL)
    When 17 : Affzo [PTH1]CCE17(NOL)
    When 18 : Affzo [PTH1]CCE18(NOL)
    When 19 : Affzo [PTH1]CCE19(NOL)
    When 20 : Affzo [PTH1]CCE20(NOL)
  Endcase
Next I
Return

$AFFICH_ACC
#----------------------------------------------------------#
# Affichage des comptes de la ligne élément de facturation #
#----------------------------------------------------------#
If dim(I)<1     Local Integer I    : Endif
If dim(PLAN)<1  Local Integer PLAN : Endif
For I=1 To GNBCOA
  If PLAN<>I : # Ne pas afficher si on se trouve en init sur le champ
    Case I
      When  1 : Affzo [PTH2]ACC1 (NOL)
      When  2 : Affzo [PTH2]ACC2 (NOL)
      When  3 : Affzo [PTH2]ACC3 (NOL)
      When  4 : Affzo [PTH2]ACC4 (NOL)
      When  5 : Affzo [PTH2]ACC5 (NOL)
      When  6 : Affzo [PTH2]ACC6 (NOL)
      When  7 : Affzo [PTH2]ACC7 (NOL)
      When  8 : Affzo [PTH2]ACC8 (NOL)
      When  9 : Affzo [PTH2]ACC9 (NOL)
      When 10 : Affzo [PTH2]ACC10(NOL)
    Endcase
  Endif
Next I
Return

$AFFICH_PFICCE
#-----------------------------------------------------------------#
# Affichage des sections analytiques ligne élément de facturation #
#-----------------------------------------------------------------#
If dim(I)<1  Local Integer I : Endif
For I=1 To GNBDIE
  Case I
    When  1 : Affzo [PTH2]PFICCE1 (NOL)
    When  2 : Affzo [PTH2]PFICCE2 (NOL)
    When  3 : Affzo [PTH2]PFICCE3 (NOL)
    When  4 : Affzo [PTH2]PFICCE4 (NOL)
    When  5 : Affzo [PTH2]PFICCE5 (NOL)
    When  6 : Affzo [PTH2]PFICCE6 (NOL)
    When  7 : Affzo [PTH2]PFICCE7 (NOL)
    When  8 : Affzo [PTH2]PFICCE8 (NOL)
    When  9 : Affzo [PTH2]PFICCE9 (NOL)
    When 10 : Affzo [PTH2]PFICCE10(NOL)
    When 11 : Affzo [PTH2]PFICCE11(NOL)
    When 12 : Affzo [PTH2]PFICCE12(NOL)
    When 13 : Affzo [PTH2]PFICCE13(NOL)
    When 14 : Affzo [PTH2]PFICCE14(NOL)
    When 15 : Affzo [PTH2]PFICCE16(NOL)
    When 16 : Affzo [PTH2]PFICCE17(NOL)
    When 17 : Affzo [PTH2]PFICCE17(NOL)
    When 18 : Affzo [PTH2]PFICCE18(NOL)
    When 19 : Affzo [PTH2]PFICCE19(NOL)
    When 20 : Affzo [PTH2]PFICCE20(NOL)
  Endcase
Next I
Return

$RAZ_CCE
#-----------------------------------------------------------#
# Effacement des sections analytiques de la ligne réception #
#-----------------------------------------------------------#
If dim(I)<1  Local Integer I : Endif
For I=1 To GNBDIE
  Case I
    When  1 : Raz [M:PTH1]CCE1 (NOL)
    When  2 : Raz [M:PTH1]CCE2 (NOL)
    When  3 : Raz [M:PTH1]CCE3 (NOL)
    When  4 : Raz [M:PTH1]CCE4 (NOL)
    When  5 : Raz [M:PTH1]CCE5 (NOL)
    When  6 : Raz [M:PTH1]CCE6 (NOL)
    When  7 : Raz [M:PTH1]CCE7 (NOL)
    When  8 : Raz [M:PTH1]CCE8 (NOL)
    When  9 : Raz [M:PTH1]CCE9 (NOL)
    When 10 : Raz [M:PTH1]CCE10(NOL)
    When 11 : Raz [M:PTH1]CCE11(NOL)
    When 12 : Raz [M:PTH1]CCE12(NOL)
    When 13 : Raz [M:PTH1]CCE13(NOL)
    When 14 : Raz [M:PTH1]CCE14(NOL)
    When 15 : Raz [M:PTH1]CCE16(NOL)
    When 16 : Raz [M:PTH1]CCE17(NOL)
    When 17 : Raz [M:PTH1]CCE17(NOL)
    When 18 : Raz [M:PTH1]CCE18(NOL)
    When 19 : Raz [M:PTH1]CCE19(NOL)
    When 20 : Raz [M:PTH1]CCE20(NOL)
  Endcase
Next I
Return

$RAZ_LINACC
#---------------------------------------------#
# Effacement des comptes de la ligne commande #
#---------------------------------------------#
If dim(J)<1  Local Integer J : Endif
For J=1 To GNBCOA
  Case J
    When  1 : Raz [M:PTH1]LINACC1 (NOL)
    When  2 : Raz [M:PTH1]LINACC2 (NOL)
    When  3 : Raz [M:PTH1]LINACC3 (NOL)
    When  4 : Raz [M:PTH1]LINACC4 (NOL)
    When  5 : Raz [M:PTH1]LINACC5 (NOL)
    When  6 : Raz [M:PTH1]LINACC6 (NOL)
    When  7 : Raz [M:PTH1]LINACC7 (NOL)
    When  8 : Raz [M:PTH1]LINACC8 (NOL)
    When  9 : Raz [M:PTH1]LINACC9 (NOL)
    When 10 : Raz [M:PTH1]LINACC10(NOL)
  Endcase
Next J
Return

######################################################################################
Subprog D_MATTOL(VALEUR)
Variable Char    VALEUR()
Call PTH_D_MATTOL(VALEUR) From TWMLIB  # Three way matching GRNA
End

######################################################################################
Subprog AM_MATTOL(VALEUR)
Variable Char    VALEUR()
End

######################################################################################
## Etiquette ajoutée par le superviseur (écran PTH1) 22/02/2012 12:59:02 (MUARN)
# Issue 70985 - 2012-02-22 by MUARN : landed cost
######################################################################################
Subprog AM_CPR(VALEUR)
Variable Decimal VALEUR
Local Shortint NOL : NOL=nolign-1
[M:PTH1]LINAMTCPR(NOL)=VALEUR*[M:PTH1]QTYSTU(NOL)
Call ARRDEV([M:PTH1]LINAMTCPR(NOL),GLOCALDEV) From TRTDIV
If !GIMPORT Affzo [PTH1]LINAMTCPR(NOL) : Endif
End

# Issue 94186 - 2013-11-06 by MUARN : landed cost et sous traitance
Subprog AS_CPRAMT(VALEUR)
Variable Decimal VALEUR
Local Shortint NOL : NOL=nolign-1
# Issue 102827 - 2014-11-03 by MUARN : nom modifiable après création
If [M:PTH1]LINTYP(NOL)>1 | [M:PTH1]CREFLG(NOL)<>0
  mkstat=2 : End
Endif
End

# Issue 97484 - 2014-03-17 by SR
######################################################################################
Subprog C_QTYWEU(VALEUR)
Variable Decimal VALEUR
Local Integer NOL : NOL = nolign-1
If VALEUR <> [M:PTH1]QTYWEU(NOL)
  Gosub CTRL_REGSTCDL
Endif
End

Subprog C_QTYVOU(VALEUR)
Variable Decimal VALEUR
Local Integer NOL : NOL = nolign-1
If VALEUR <> [M:PTH1]QTYVOU(NOL)
  Gosub CTRL_REGSTCDL
Endif
End

$CTRL_REGSTCDL
Local Integer OK
# Des charges de cette ligne ont-elles déjà été rapprochées
If [M:PTH1]STCNUM(NOL) <> ""
    Filter [F:STCD]Where VCRTYP = 6 & VCRNUM = [M:PTH0]PTHNUM & VCRLIN = [M:PTH1]PTDLIN(NOL) & STCRFLG=2
    Look [F:STCD]STCD1 First
    Filter [F:STCD]
    If !fstat
        # Des charges rapprochées existent pour ce document. Voulez-vous continuer ?
        OK =2 :Call OUINON (mess(470,194,1),OK) From GESECRAN
        If OK<>2  : mkstat = 2 : Endif
    Endif
Endif
Return #MAE, bug 112048
# End issue 97484
######################################################################################
######################################################################################
## Etiquette ajoutée par le superviseur (écran PTH1) 16/07/2014 11:23:52 (HCB) 71276
######################################################################################
Subprog C_LOT(VALEUR)
Variable Char    VALEUR()
If VALEUR <> [M]LOT (nolign-1)
   If dim([M]ECCVALMAJ) > 0
      Raz [M]ECCVALMAJ(nolign-1)
      Raz [M]ECCVALMIN(nolign-1)
      Raz [M]ECCSAIFLG(nolign-1)
   Endif
Endif
End


######################################################################################
# Issue 106506 - 2015-04-21 by SR : Landed Cost
######################################################################################
Subprog AS_WSHDSOLDE(VALEUR)
Variable Integer VALEUR
If [M:PTH1]SHIPNUM(nolign-1) = "" | [M:PTH1]SHDQTYSTU(nolign-1) = 0
   mkstat = 2
   End
Endif
End

######################################################################################
# Issue 71069 - 2015-12-16 by MUARN : PJT
Subprog AS_PJT(VALEUR)
Variable Char    VALEUR()
Local Shortint NOL : NOL=nolign-1
If !GIMPORT & [M:PTH1]LINTYP(NOL)>2
  mkstat=2 : End
Endif
End

# Issue 71069 - 2016-09-06 by MUARN : pjt
Subprog AM_PJTH(VALEUR)
Variable Char    VALEUR()
Gosub AM_PJTH From SUBPTHD
End
